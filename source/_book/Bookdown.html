<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>R: Uma Introdução para economistas</title>
  <meta name="description" content="R: Uma Introdução para economistas" />
  <meta name="generator" content="bookdown 0.18 and GitBook 2.6.7" />

  <meta property="og:title" content="R: Uma Introdução para economistas" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="R: Uma Introdução para economistas" />
  
  
  

<meta name="author" content="Daniel Coutinho" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  


<script src="libs/header-attrs-2.1/header-attrs.js"></script>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">


      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">R: Uma Introdução para economistas</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="header">
<h1 class="title">R: Uma Introdução para economistas</h1>
<p class="author"><em>Daniel Coutinho</em></p>
<p class="date"><em>Última Atualização: 01/05/2020</em></p>
</div>
<p>#Introdução</p>
<p>Existem muitos softwares de estatística, mas o R é um dos mais populares. O R é um software gratuito, o que justifica a sua escolha. Mas além disso, a comunidade é muito ativa, desenvolvendo muitos pacotes - inclusive para econometria. O R não é tão amigável quanto o gretl: não existem menus para escolher como estimar. Entretanto, ele é muito mais flexível. Assim, o R tem ganho cada vez mais espaço entre aqueles que fazem econometria.</p>
<p>Este manual foi criado para ajudar a introduzir economistas ao R. Com isso, ele é mais voltado para exemplos de tratamento de dados e ferramentas estatísticas usadas pelos economistas. Existem outros excelentes livros que ensinam a usar o R, e alguns aplicados à econometria. Eles estão listados nas referências deste manual. Mas nenhum deles é em português, e muitos são muito detalhistas e longos. Este manual tenta servir como algo menos extenso que os livros. Portanto, uma consulta aos livros pode ser muito útil.</p>
<p>Esta é a segunda versão do manual, que foi extensivamente reescrito em meados de 2017 e início de 2018. Não é necessário nenhuma experiência anterior com programação, mas é necessário saber (alguma) econometria. O autor agradece as muitas pessoas na PUC-Rio que ajudaram com o R, bem como os seis meses trabalhando no Dlab. As duas versões anteriores foram escritas, originalmente, em LaTeX, o <em>gold standard</em> da edição de texto acadêmica.Essa versão foi escrita usando o bookdown, um pacote do R para produzir livros para a internet.</p>
<p>Algumas palavras sobre a filosofia por trás desse manual são necessárias: a ideia é tirar o leitor do chão e colocar ele pronto para fazer as coisas básicas de econometria rapidamente. Isso envolve notórias omissões. O autor muitas vezes sugere consultar o help, o que deve ser visto não como preguiça, mas sim como a única maneira de fazer as coisas: existem mais de 12 mil pacotes disponíveis para o R, e nenhum ser humano jamais conseguirá explorar e entender todos. O autor usou, diretamente, uma dúzia pacotes, se tanto. E invariavelmente é necessário consultar o help para saber qual o nome do argumento que faz alguma coisa específica. Assim, a ideia aqui é entender as ideias gerais do R, os comandos básicos e o mínimo do vocabulário para saber consultar/ler o help.</p>
<p>Definitivamente esse manual deve ser lido com o R aberto e tentando entender cada um dos comandos que são ditos aqui. Uma leitura comparativa entre o help e o que eu coloco no manual sobre cada comando é provavelmente a melhor maneira de proceder. Tentar replicar tudo que eu faço é uma maneira garantida de aprender. As seções Hands on propõe exercícios específicos para serem feitos no R. O capítulo projetinhos tem o mesmo objetivo, mas com exercícios que são mais extensos.</p>
<p>O manual é dividido em três partes: a primeira trata de como fazer econometria no R: é o coração do manual e é de principal interesse dos economistas; a segunda parte trata de como programar no R, o que é útil em algumas atividades um pouco mais avançadas. A terceira parte será dedicada a algumas coisas de matemática no R. Seções marcadas com um * são mais indigestas para a primeira leitura.</p>

<p>#Primeiros Passos</p>
<p>##Instalação</p>
<p>###Instalando o R e o RStudio</p>
<p>Instalar o R é trivial: basta ir no <a href="http://cran.r-project.org/" class="uri">http://cran.r-project.org/</a> e baixar a versão para o seu computador. Exceto se você usar alguma distribuição de Linux (Ubuntu, por exemplo): ai é mais difícil, mas o próprio CRAN dá instruções de como fazer. Depois, recomenda-se baixar o R Studio, disponível em <a href="https://www.rstudio.org/" class="uri">https://www.rstudio.org/</a>. O R Studio é uma IDE (Integrated Development Enviroment), que facilita muito a vida na hora de programar - especialmente dando sugestões de comandos e mostrando quais variáveis estão salvas no ambiente do R. Assim, sugiro instalar o R Studio, que é bem tranquilo. Para usar o R Studio, você precisa ter o R.</p>
<p>###Uma alternativa</p>
<p>Se o seu computador tem um processador multi-core, pode ser interessante instalar o Microsoft R, disponível em <a href="http://mran.microsoft.com/" class="uri">http://mran.microsoft.com/</a>. Ele é idêntico ao R, mas vem com uma biblioteca que tira vantagem dos vários núcleos do processador, o que o R padrão não faz. A principal desvantagem é que ele é atualizado com menos frequência, e a biblioteca que usa mais de um núcleo não está disponível para o Mac. Ele funciona com o R Studio.</p>
<p>###Interface</p>
<p>A interface do R Studio mostra 4 espaços diferentes: no canto esquerdo superior, existe uma tela chamada source (se ela não estiver lá, tente usar ctrl + shift + n para abrir); a direita dela, o ambiente; no canto inferior esquerdo, está o console; e no canto inferior direito está uma tela multiuso, que deve vir com as abas plot, files. Cada uma dessas será explicada, por alto, nesta seção</p>
<p>A que mais nos interessa, em um primeiro momento, é o console. Nele, você pode passar comandos direto para o R. Digitando 2 + 2 nele e clicando em enter, o resultado deve aparecer na tela. Em geral, é nele que você vai trabalhar. Entretanto, escrever código muito longos no console é muito ruim. O console é desorganizado, não permite salvar o código passado para ele para ser usado mais tarde e não permite com que você corrija erros com facilidade. O source serve justamente para escrever um código longo - uma função ou uma simulação, por exemplo - que pode ser executado no console. Para isso, basta selecionar o conteúdo e dar ctrl + enter ou chegar no fim da linha e usar ctrl + enter.</p>
<p>A tela do canto direito inferior é uma “geleia geral”: a aba plots é onde os gráficos que faremos vão aparecer; a aba files permite você ver arquivos em diferentes pastas do computador. Estas são as abas mais importantes e que mais serão usadas. Em cima desta tela, há a tela <em>environment</em>, que mostra as variáveis que foram criadas e estão disponíveis para o R usar</p>
<p>##Erros, Warnings e letras vermelhas</p>
<p>Tão importante quanto saber fazer a coisa certa é saber quando temos um problema. Existem dois tipos de erro:</p>
<ul>
<li>Error: esses são de fato erros, e o R não consegue proceder. O que você escreveu tem algum problema grave e não pode ser executado.</li>
<li>Warning: o R conseguiu fazer o que você pediu, mas alguma coisa esquisita aconteceu, e o R está te avisando.</li>
</ul>
<p>Veja que em ambos os casos a mensagem vai aparecer em vermelho no console. <em>Error</em> e <em>warnings</em> vem das mais diferentes formas (afinal, é possível errar de diferentes formas). Alguns são claros, como tentar somar um número e uma letra:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="dv">2</span> <span class="op">+</span><span class="st"> &quot;a&quot;</span></span></code></pre></div>
<pre><code>## Error in 2 + &quot;a&quot;: argumento não-numérico para operador binário</code></pre>
<p>(Apesar de operador binário não ser exatamente óbvio)</p>
<p>Outros são mais misteriosos, e quando encontramos um erro impossível de entender, coloque o <em>output</em> do console no google. Typos geram muitos erros (ex.: esquecer o parêntese, errar o nome de um objeto). Em um código longo, descobrir o erro pode ser difícil. Existem ferramentas para isso, e o próprio <em>source</em> do RStudio indica linhas com algum erro com um x vermelho do lado do número da linha. Em geral, em um código muito longo, não é uma estratégia ruim escrever uma parte do código, testar e debugar (retirar os erros) ela. Funções ajudam a fazer isso: trataremos delas mais a frente.</p>
<p>É importante notar que, apesar de uma linha de código que devolva um <em>warning</em> não está errada, ela pode muito bem fazer uma coisa que você não quer. Assim, um warning surpresa deve ser visto com bastante cuidado e normalmente você não deve ignorar um warning.</p>
<p>Veja que essas mensagens não são as únicas que aparecem em vermelho no R: quando o R instala ou carrega um pacote ele exibe algumas coisas em vermelho<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. Não se preocupe: isso não quer dizer que o R encontrou algum erro ou warning ao instalar o pacote, é apenas o comportamento padrão do R.</p>
<p>###Pacotes</p>
<p>O grande atrativo do R são os pacotes. Para instalar um pacote, basta digitar no console:</p>
<pre><code>install.packages(&quot;nome-do-pacote&quot;)</code></pre>
<p>É necessário colocar as aspas para o pacote instalar. Uma vez instalado, o pacote não é carregado automaticamente. Para carregar o pacote, basta digitar no console:</p>
<pre><code>library(nome-do-pacote)</code></pre>
<p>Agora as aspas não são necessárias.</p>
<p>Instalar pacote por pacote pode ser uma tarefa chata. Além do mais, isto exige que você saiba quais são os pacotes que fazem cada coisa. Felizmente, o CRAN mantém coleções de pacotes de determinados temas, chamados de Task Views. Existe um de econometria, e para instalar ele é necessário instalar o pacote ctv , e depois o task view de econometria:</p>
<pre><code>install.packages(&quot;ctv&quot;)
library(ctv)
install.views(&quot;Econometrics&quot;)</code></pre>
<p>Como são muitos pacotes, esta operação pode tomar algum tempo. Em geral, muitos dos pacotes nos task view não são tão úteis, então pode ser interessante ir no cran, e visitar os task views para selecionar quais pacotes de lá fazem o que você precisa fazer. Existem vários pacotes, para diferentes áreas. Para os economistas, além do pacote de econometria, os pacotes de Time Series, Bayesian, Finance, Machine Learning podem ser de interesse. De fato, com a expansão das áreas de pesquisas, muitos outros task views podem ser de interesse! Recomenda-se visitar o cran para ter uma visão do que está disponível.</p>
<table>
<tr>
<th bgcolor="#adadeb">
Hands on!
</th>
</tr>
<tr>
<td bgcolor="#adadeb">
Vamos instalar um primeiro pacote que adiciona vários comandos importantes para econometria e alguns datasets de livros de econometria (como o Stock Watson). O nome do pacote é AER. Ele vai instalar vários outros pacotes que ele necessita para funcionar, então a instalação pode demorar um pouco. Ele será usado de agora por diante, então tenham certeza que ele está carregado, ou seja, que vocês sempre estão usando o <code>library(AER)</code> quando abrem o R.
</td>
</tr>
</table>
<p>##Ajuda</p>
<p>Em 90% do tempo você vai precisar de olhar o help: seja para lembrar que opções estão disponíveis em um comando, ou lembrar exatamente o que o comando faz, ou descobrir qual o comando para fazer alguma coisa específica que você só tem uma palavra chave: ``Como gera números saídos de uma distribuição normal mesmo?’’<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<p>Se você sabe o comando e quer ler o help deste comando, basta fazer <code>?comando</code>. Por exemplo, se você quiser saber o que o comando rnorm faz e quais as opções ele oferece, basta digitar no console <code>?rnorm</code>. Se você não sabe o nome do comando, mas quer saber todos os comandos que estão relacionados a uma determinada palavra chave, use <code>??palavra</code>. Por exemplo, se você quiser saber todos os comandos que envolvem a distribuição normal, basta usar <code>??normal</code>. Observe que, se você tiver muitos pacotes, isto pode demorar um pouco, já que exige que o R procure cada pacote que se referencie àquela palavra.</p>
<p>Você também pode estar interessado em todos os comandos de um pacote. Neste caso, a melhor solução é é usar <code>help(package=``nome-do-pacote'')</code>.</p>
<p>##Comentando</p>
<p>Em geral, quando se escreve um código, é importante explicar o que algumas partes do código fazem. Isso não é exclusivo para o caso em que o código vai ser distribuído: pelo contrário, o você do futuro vai agradecer muito o você do passado se você comentar o seu código. Para comentar o código no R, usa-se o #. Tudo depois do # vira um comentário é ignorado pelo R. Assim, suponha que queremos explicar o que o parâmetro a abaixo é: suponha que ele vem de um outro estudo, de Cleese et. al. (1975). Então:</p>
<pre><code>    a &lt;- 1 #Retirado de Cleese et. al. (1975)</code></pre>
<p>A regra geral para comentários é: eles não devem ser óbvios (ex.: <code>1 + 1 # somando dois números</code>) mas devem ajudar o leitor - que eventualmente será você mesmo - a entender o que está sendo feito - especialmente em momentos mais obscuros.</p>
<p>##Objetos*</p>
<p>Como muitas linguagens de programação, existem vários tipos de objetos no R. Objetos são maneiras diferentes de guardar os dados. Os mais usados e mais comuns são:</p>
<ul>
<li>Vetor</li>
<li>Matriz</li>
<li>Dataframe</li>
<li>Lista</li>
</ul>
<p>Em geral, para dar um nome a um objeto, usamos uma setinha, <code>&lt;-</code>, que é o sinal de menor e o menos. Podemos usar o igual também, mas é preferível a seta. Então, se fizermos <code>a &lt;- 1</code> e digitarmos a, o R vai mostrar 1. Veja que por padrão o R não mostra o valor de objetos que você acabou de criar, e vai mostrar apenas se você pedir.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>a &lt;-<span class="st"> </span><span class="dv">1</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>a</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>Vetores são só coleções unidimensionais de “coisas”. Para criar um vetor, basta usar <code>c()</code> e separar os elementos por vírgula. Suponha que queremos listar os 4 primeiros números primos, então poderíamos fazer:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>primos &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>)</span></code></pre></div>
<p>Assim, ao digitar no console <code>primos</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>primos</span></code></pre></div>
<pre><code>## [1] 2 3 5 7</code></pre>
<p>Podemos fazer operações com vetores, como somar, subtrair, multiplicar e dividir. Observe que multiplicar um vetor não é multiplicar uma matriz: o R vai multiplicar elemento a elemento. Então <code>c(1,2,3)*c(1,2,3)</code> gera como resultado:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>)<span class="op">*</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>)</span></code></pre></div>
<pre><code>## [1] 1 4 9</code></pre>
<p>Para multiplicar dois vetores como multiplicariamos usualmente, usamos <code>%*%</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>)<span class="op">%*%</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>)</span></code></pre></div>
<pre><code>##      [,1]
## [1,]   14</code></pre>
<p>Podemos agrupar vetores em matrizes, usando os comandos cbind e rbind, que transforma cada vetor em uma coluna ou em uma linha, respectivamente. Assim, se fizermos <code>cbind(c(1,2),c(3,4))</code>, teríamos:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">cbind</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>),<span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">4</span>))</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4</code></pre>
<p>Se usarmos o <code>rbind(c(1,2),c(3,4))</code>, teríamos:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>),<span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">4</span>))</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4</code></pre>
<p>Existe outra maneira de fazer matrizes, com o comando <code>matrix</code>. Veja que as operações <code>*</code>e <code>%*%</code> funcionam assim como elas funcionam com vetores: <code>*</code>multiplica elemento a elemento a matriz e <code>%*%</code>multiplica a matriz da maneira usual:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a>A &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>),<span class="dt">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb20-2"><a href="#cb20-2"></a>B &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>),<span class="dt">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb20-3"><a href="#cb20-3"></a>A<span class="op">*</span>B</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4</code></pre>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a>A<span class="op">%*%</span>B</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]    4    4
## [2,]    6    6</code></pre>
<p>Observe que matrizes forçam todos os elementos a serem do mesmo tipo. Suponha que você quer fazer uma matriz com nomes e notas de alunos, e quer tirar a média das notas. O R vai acusar um erro, porque as notas não serão do tipo numérico, e sim do tipo <em>character</em>, que é o tipo do nome dos alunos. Para contornar este problema e poder agregar vetores com diferentes tipos - como é o caso do exemplo de notas de alunos e notas é que existe o objeto do tipo dataframe. O comando data.frame funciona como um cbind, que permite diferente juntar vetores de diferentes tipos em uma “matriz”.</p>
<p>Observe que, para formar matrizes e dataframes, os vetores tem que ter o mesmo tamanho, o que nem sempre é possível ou desejável. Neste contexto, existem as listas, que são um <em>anything goes</em>. Você pode ter uma lista de vetores, uma lista de variáveis, uma lista de listas etc. Além disto, você pode dar nomes as coisas dentro dela e chamar pelo nome. Por exemplo, se fizermos:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a>um.teste &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">Ola =</span> <span class="st">&quot;Olá&quot;</span>, <span class="dt">Dia =</span> <span class="kw">date</span>())</span></code></pre></div>
<p>E depois digitarmos <code>um.teste$Dia</code>, ele deve exibir qual a data atual. Digite <code>um.teste$Ola</code> e ele deve exibir um Olá na sua tela:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a>um.teste<span class="op">$</span>Dia</span></code></pre></div>
<pre><code>## [1] &quot;Fri May  1 10:58:58 2020&quot;</code></pre>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a>um.teste<span class="op">$</span>Ola</span></code></pre></div>
<pre><code>## [1] &quot;Olá&quot;</code></pre>
<p>Observem que eu usei um “Olá”, entre aspas na lista. Aspas são bastante importante. Por exemplo, faça: <code>c("Bom","Dia")</code>. O R vai mostrar na tela as duas palavras. Agora, suponha que você esquecesse as aspas no Dia. Agora, o R dará um erro: ele afirma que o objeto Dia não foi encontrado.</p>
<p>Assim, se quisermos digitar palavras, frases, letras, devemos colocar eles entre aspas. Caso contrário, o R vai buscar o objeto com aquele nome. De maneira bastante grosseira, expressões desse tipo são chamadas de string.</p>
<p>Familiarizados com como instalar, pedir ajuda, e os principais objetos do R, podemos proceder para a primeira etapa de qualquer análise de dados: como inserir os dados no R.</p>

<p>#Inserindo e Manipulando Dados no R: O básico.</p>
<p>Só podemos fazer análise de dados se tivermos… dados. Este capítulo ensina a colocar os dados no R e a manipular eles como para criar variáveis necessárias ou limpar os dados antes de iniciarmos a análise.</p>
<p>Esse capítulo não tenta ser enciclopédico nem detalhista: pelo contrário, ele omite muitas coisas. A omissão mais grave é, sem dúvida alguma, os pacotes do <em>Tidyverse</em>. A omissão se deve a ignorância do autor em usar estes pacotes.</p>
<p>##Arquivos excel/csv</p>
<p>O R não lê diretamente arquivos excel (.xls ou .xlsx), apesar de alguns pacotes permitirem o R ler estes arquivos. Mas esta não é a melhor opção: o ideal é salvar a planilha com os dados em outro formato, como .csv. Isto não é difícil: basta, no excel, ir em salvar como, e embaixo na opção de nome do arquivo há a opção de escolher o formato. O que queremos é <strong>csv (separado por vírgula)</strong></p>
<p>Para carregar o arquivo no R, precisamos saber algumas poucas coisas:</p>
<ul>
<li>O seu excel usa ponto ou vírgula como separador decimal?
*Aonde está o arquivo</li>
</ul>
<p>O item 1 importa porque, se o separador decimal for vírgula, usamos o comando <code>read.csv2</code>. Caso contrário, usamos <code>read.csv</code>. O comando é bem simples: basta passar o caminho (aquele C:/Usuário/…). Por exemplo, suponha que eu tenho um csv chamado dados, e quero importar ele para o R. Ele fica no C:/Usuário/Autor/Manual. Então, eu faria:</p>
<pre><code>read.csv2(&quot;C:/Usuário/Autor/Manual/dados.csv&quot;)</code></pre>
<p>Observe que o caminho para o arquivo está entre aspas e que você precisa colocar a extensão do arquivo no fim - o .csv. Mais uma observação: em geral, se você copiar e colar o caminho como o Windows dá o nome de arquivo com  ao invés de /. O R só lê usando /, então você tem que alterar isto.</p>
<p>Neste caso, o R só vai exibir os dados, e não vai salvar eles dentro do R. Você não vai poder fazer nada com os dados. Para podermos usar eles mais tarde, precisamos salvar ele no ambiente do R. Para isto, basta criar um objeto com os dados, como já fizemos no capítulo anterior. Por exemplo, podemos ser extremamente criativos e chamar o objeto de dados. Nesse caso:</p>
<pre><code>dados &lt;- read.csv2(&quot;C:/Usuário/Autor/Manual/dados.csv&quot;)</code></pre>
<p>Se você não está familiarizado com usar o caminho dos arquivos, isto pode parecer excessivamente complicado. Felizmente, o R permite com que você escolha o caminho do arquivo de maneira mais usual, usando um menu e o mouse. Para isto, precisamos alterar o comando acima ligeiramente:</p>
<pre><code>dados &lt;- read.csv2(file.choose())</code></pre>
<p>Isto vai abrir o menu e permitir que você escolha o arquivo como um menu do word. Entretanto, apesar de ser mais fácil, essa solução pode ser extremamente inconveniente: toda vez que você for rodar o programa você vai ter que escolher. Apesar de trabalhar com o caminho ser um pouco mais chato, isto poupa muito tempo.</p>
<p>##Lendo arquivos do stata e outros pacotes estatísticos</p>
<p>Muitos arquivos com dados ainda são distribuídos em versão de programas estatísticos, como o stata. É fácil ler estes arquivos usando o pacote <em>foreign</em>. Normalmente este pacote já vem instalado, mas caso você não tenha, você pode instalar como qualquer outro pacote. Ele permite ler dados do SAS, SPSS, entre outros. A ideia é a mesma da seção anterior, mas com comandos diferentes para cada tipo de arquivo: o ideal é consultar o help do pacote.</p>
<p>Por exemplo, para ler um arquivo do stata, o comando no pacote foreign é <code>read.dta</code>. Suponha que, ao invés de ser um arquivo .csv, meus dados do exemplo anterior estivessem salvos em formato do stata. Bastaria fazer:</p>
<pre><code>dados &lt;- read.dta(&quot;C:/Usuário/Autor/Manual/dados.dta&quot;)</code></pre>
<p><strong>Porém</strong>, o <code>read.dta</code> só lê arquivos criados pelo stata até a versão 12. Para versões posteriores do stata, existe um pacote chamado <em>readstata13</em>. Se, ao usar o <code>read.dta</code> você receber uma mensagem de erro, vale a pena checar o <em>readstata13</em>.</p>
<p>##Lendo arquivos muito grandes</p>
<p>Algumas bases de dados podem ser muito grandes, e o R pode sofrer para abrir - mesmo em computadores com muita memória e muito processamento. Para driblar o problema, o pacote <em>data.table</em> ajuda a carregar arquivos grandes para o R. O pacote trás várias opções para trabalhar com os dados carregados, que não serão tratadas aqui.</p>
<p>Outra opção é o pacote <em>readr</em>, que funciona de forma parecida com o comando padrão do R. Para ler um csv que usa vírgulas para separar decimais, o comando é <code>read\_csv2</code> - basicamente idêntico ao comando padrão do R, mas com uma linha no lugar do ponto. Ao carregar o arquivo, tudo funciona como o usual. Uma pequena diferença é que o nome das variáveis é preservado: assim, uma variável chamada “Nome da variável” continuará se chamando “Nome da variável”, ao invés do padrão do <code>read.csv2</code> de transformar em “Nome.da.variável”. Apesar de isso parecer bom a primeira vista, dificulta acessar as variáveis mais tarde, já que o R não entende nomes com espaço para objetos.</p>
<p>##O pacote BETS (e muitos outros)</p>
<p>Para dados do Brasil, especialmente dados macroeconômicos, o pacote <strong>BETS</strong> é uma excelente alternativa para puxar os dados via BCB/IBGE. O <strong>BETS</strong> permite com que, direto do R, você busque e salve séries disponíveis em diversas bases de dados - entre elas o BCB e o IBGE. O cerne do BETS são os comandos <code>BETSsearch()</code> e <code>BETSget()</code>. O <code>BETSsearch()</code> permite buscarmos por uma palavra chave e retorna informações da série - frequência, fonte, início e fim e um código. O <code>BETSget()</code> permite com que você recupere a série a partir do código. Para recuperarmos o IPCA, fariamos:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">library</span>(BETS)</span>
<span id="cb33-2"><a href="#cb33-2"></a></span>
<span id="cb33-3"><a href="#cb33-3"></a>busca &lt;-<span class="st"> </span><span class="kw">BETSsearch</span>(<span class="st">&quot;IPCA&quot;</span>)</span></code></pre></div>
<pre><code>## 
## BETS-package: Found 51 out of 18706 time series.</code></pre>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1"></a><span class="co">#View(busca)</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>IPCA &lt;-<span class="st"> </span><span class="kw">BETSget</span>(<span class="dv">433</span>, <span class="dt">from =</span> <span class="st">&quot;2002-01-01&quot;</span>)</span>
<span id="cb35-3"><a href="#cb35-3"></a><span class="kw">plot</span>(IPCA)</span></code></pre></div>
<p><img src="Bookdown_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<p>Veja que colocamos o <code>View(busca)</code> comentado apenas para este post: ao rodar essa linha, uma aba no RStudio abrirá e mostrará todas as séries que se encaixam neste critério.</p>
<p>Veja que este não é o único pacote disponível para baixar dados! Existem muitos outros, e a melhor maneira é fuçar o CRAN. (Mas em breve devo adicionar mais um aqui, o <strong>Quandl</strong>)</p>
<p>##Trabalhando com os dados</p>
<p>Uma vez carregado os dados, pode ser necessário manipular os dados de diversas maneiras. Esta seção tratará de algumas das maneiras mais comuns.</p>
<p>###Selecionando linhas/colunas/elementos</p>
<p>Selecionar uma linha ou uma coluna específica de uma base de dados é essencial. Se quisermos rodar uma regressão e cada coluna da tabela é uma variável, então temos que ser capazes de informar ao R quais colunas serão usadas como variável explicada e quais como variável explicativa. O R usa a notação de matrizes com colchetes, então para selecionar a 4ª linha da base de dados chamada dados, basta fazer <code>dados[4,]</code>. Veja que colocamos a vírgula e depois deixamos em branco, informando ao R que queremos todas as colunas. Para obter todas as linhas da quarta coluna, fazemos <code>dados[,4]</code>.</p>
<p>E se quisermos apenas algumas linhas ou algumas colunas? Podemos passar um vetor dizendo quais são essas linhas e/ou colunas. Por exemplo, se quisermos as linhas 1 <strong>a</strong> 4, podemos passar um <code>dados[1:4,]</code>. E se quisermos as linhas 1 <strong>e</strong> 4, podemos fazer: <code>dados[c(1,4),]</code></p>
<p>Outra maneira, bastante útil, de selecionar variáveis é pelo nome delas. Suponha que os dados vem com nomes id, renda, escolaridade. Para selecionar a variável renda, basta fazer <code>dados$renda</code>. Veja que isso exige saber como (e se) o R importou os nomes. Para isso, a função <code>names</code> permite saber quais os nomes das variáveis. Logo <code>names(dados)</code> vai retornar os nomes das variáveis. Em geral, os espaços são substituídos por pontos, logo uma variável anos de estudo se tornará <code>anos.de.estudo</code>. Veja que também podemos acessar as variáveis em um data.frame usando <code>nome do data.frame$nome da variável</code>. Assim, se temos um data.frame com nome dados e queremos acessar a variável renda, bastaria fazer <code>dados$renda</code>.</p>
<p>Veja que podemos querer selecionar apenas um elemento. No caso de vetor, é a única coisa que faz sentido: o vetor só tem uma dimensão (uma linha ou uma coluna), então só podemos pegar um elemento dele. Suponha que temos o vetor <span class="math inline">\(\mathbf{v}\)</span> e queremos o décimo elemento: basta fazer <code>v[10]</code>. Veja que não usamos vírgulas, que são usadas apenas para separar as dimensões. Se quisermos um elemento de uma matriz, basta passar a linha e a coluna dele, respectivamente. Por exemplo, o elemento da segunda linha e quinta coluna do dataframe dados é obtido usando <code>dados[2,5]</code>.</p>
<p>Mas o R permite você selecionar o elemento de uma matriz como se fosse um vetor! Suponha uma matriz - chamaremos ela de <span class="math inline">\(\mathbf{M}\)</span> - com 5 linha e 5 colunas. O último elemento da matriz pode ser obtido com <code>M[5,5]</code> ou, equivalentemente, <code>M[25]</code>. Veja que o 25 não é a toa, no total a matriz tem 25 elementos: logo, o último tem que ser o membro 25.</p>
<p>As vezes, queremos transformar uma variável contínua em uma <em>dummy</em>. Pode ser o caso que queremos isolar apenas aqueles que recebem menos de um salário mínimo, e queremos que quem tiver menos de um salário mínimo tenha valor 1 e, caso contrário, 0. Suponha que o salário mínimo seja 678, e que a variável de salários se chame w. Então, bastaria fazer:</p>
<pre><code>sal.min &lt;- w &lt; 678</code></pre>
<p>Observe que o R vai gerar um vetor de Verdadeiros e Falso. É possível converter para numérico, mas não há nenhuma necessidade, uma vez que o R é capaz de interpretar o verdadeiro ou falso como uma <em>dummy</em> na regressão.</p>
<p>O que estamos fazendo é apenas uma operação de compara cada número do vetor ao número 678. Testamos se ele é menor (&lt;), mas poderíamos ver que números são maiores (&gt;), iguais (==)<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>, menor ou igual (&lt;=) ou maior ou igual (&gt;=). Estes operadores não são apenas úteis para criar <em>dummies</em>, mas também pode servir para escrever funções, que será tratado mais a frente.</p>
<p>Pode ocorrer de a variável vir como um vetor de palavras ou siglas. Suponha que estamos trabalhando com um painel que tem variação temporal e por estado, e o vetor de estados vem com as siglas dos estados (RJ,SP,ES,MG,DF…). Se quisermos usar efeitos fixos de uma maneira extremamente ingênua, poderíamos criar dummies para cada estado e estimar o efeito fixo de cada estado. Esta não é uma maneira inteligente de fazer, já que existem pacotes para fazer estimação usando efeitos fixos com bem menos trabalho, que serão tratados no próximo capítulo. Mas, no momento, vamos ignorar esta opção e tentar criar uma dummy para cada estado.</p>
<p>Uma possível solução era criar um vetor para cada estado (Ou talvez uma matriz com n linha e o número de colunas sendo igual o número de estados), ler cada posição do vetor das siglas usando um loop e colocar um 1 na coluna correspondente, criando um vetor índice para o R buscar qual coluna é relacionada com cada estado… Se a explicação anterior bagunçou o seu cérebro, não se preocupe: ela é complicada, e o R não exige nada tão complicado<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></p>
<p>Uma solução muito mais simples é usar o comando factors, que gera automaticamente dummies para cada categoria. Assim, RJ vira uma dummy, SP outra etc. Isso é automático, e podemos jogar direto numa regressão. Assim, suponha que temos uma base de dados chama dados e a coluna 2 é a coluna com os estados. Nesse caso: <code>estados &lt;- factor(dados[,2])</code>. Poderíamos usar estados diretamente na regressão, que será tratada no capítulo seguinte.</p>
<p>Uma nota: a partir da versão 4.0 do R, o comportamento ao importar um arquivo tipo csv mudou. Antes, colunas de caracteres eram automaticamente convertidas em fatores. Agora, as colunas de caracteres permanemce sendo caracteres. Você pode mudar isso coloca no <code>read.csv</code> <code>stringAsFctors = T</code>. Você pode mudar na mão também. Isso é extremamente inconveniente se o seu plano é fazer uma regressão linear, mas extremamente conveniente pra outra parte dos usuários.</p>

<p>#Regressão Básica</p>
<p>O coração de econometria é o modelo de regressão linear, estimado por Mínimos Quadrados Ordinários. Mas muitos outros métodos são úteis, como modelos logit, probit, variáveis instrumentais e modelos para painel. Este capítulo trata - finalmente! - de modelos de regressão no R.</p>
<p>##Mínimos quadrados ordinários</p>
<p>Suponha que carregamos uma base de dados (chamada dados), e que esta base tem as variáveis <span class="math inline">\(y, x.1,x.2,x.13\)</span> e que nosso objetivo é estimar um modelo da forma: <span class="math inline">\(y = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \beta_3 x_3 + \epsilon\)</span>. O comando que faz estimativa por mínimos quadrados é o <code>lm</code> e para estimarmos a regressão proposta basta fazer:</p>
<pre><code>reg &lt;- lm(y ~ x.1 + x.2 + x.3 + x.4, data = dados)</code></pre>
<p>Usamos o ~ para separar a variável explicada (à esquerda do til) das explicativas (à direita do til), e para separar as explicativas usamos o +. A opção <em>data</em> diz ao R onde buscar as variáveis.</p>
<p>Agora, o objeto reg<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> tem o modelo estimado. Para obter uma tabela usual de regressão, com valor do coeficiente, erro padrão, estatística t e p-valor, <span class="math inline">\(R^2\)</span> ajustado, e o teste F para os coeficientes basta usar <code>summary(reg)</code>. No contexto de regressão linear, podemos querer fazer uma série de coisas, que são explicadas a seguir.</p>
<p><strong>Atenção: Séries Temporais e o lm</strong>
Objetos de série temporal são armazenados pelo R de uma maneira especial - uma vez que você transforma ele em um objeto de série temporal. Entretanto, você <em>não</em> deve passar um objeto de série temporal para o <code>lm()</code>, já que o <code>lm</code> vai ignorar o formato de série temporal. Assim, estimar um modelo AR(1) usando <code>lm(y ~ lag(y))</code> vai gerar uma regressão com coeficiente 1 para lag(y) e <span class="math inline">\(R^2 = 1\)</span>. De fato, a regressão feita foi y em y - o que não é uma regressão muito emocionante.</p>
<p>###Testes de hipótese</p>
<p>Suponha que queremos testar a significância conjunta de x.2 e x.3. Precisamos fazer um teste F. Uma maneira é estimar um novo modelo, que chamaremos de reg.2, só com o x.1: <code>reg.2 &lt;- lm(y ~ x.1)</code></p>
<p>Agora, para testar a significância conjunta de x.2 e x.3 basta fazer <code>anova(reg,reg.2)</code> e o R reportará os valores do teste (incluindo o p valor)</p>
<p>Testes mais gerais também estão disponíveis, pelo pacote car<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>. O comando é <code>linearHypotesis</code> com o primeiro argumento sendo o objeto com o modelo. O segundo comando é a hipótese que estamos testando, entre aspas, e entramos ele de maneira extremamente intuitiva: suponha que no exemplo acima queremos testar se o coeficiente de x.2 é igual ao coeficiente de x.4. Nesse caso, o comando se resumiria a <code>linearHypotesis(reg,"x.2 = x.4")</code>. Várias opções podem ser usadas, como usar estimadores de erro padrão robustos a heterocedasticidade. Recomendamos que o leitor olhe o help do comando no R.</p>
<p>###Erros padrões robustos</p>
<p>Na presença de heterocedasticidade ou autocorrelação, os erros padrões usuais não são confiáveis. Infelizmente, o comando <code>summary</code> não exibe erros robustos por default e nem permite alterar os erros padrões exibidos. Felizmente, o pacote lmtest traz uma opção para o sumário padrão do R. A primeira coisa a fazer é carregar o pacote sandwich (<code>library(sandwich)</code>). O comando é coeftest e a sintaxe é curiosa. No caso do nosso exemplo, se quisermos obter erros robustos a heterocedasticidade:</p>
<pre><code>coeftest(reg, vcov. = vcovHC(reg))</code></pre>
<p>Uma explicação: O comando coeftest chama o comando vcovHC do pacote sandwich. Por sua vez, o comando vcovHC precisa saber qual o modelo que vai ter erros robustos. Por isso uma função que recebe uma função. Veja que se quisermos erros robustos a heterocedasticidade e autocorrelação, o comando vira vcovHAC.</p>
<p>###Logs</p>
<p>Muitas vezes queremos fazer as regressões não com as variáveis em nível, mas com as variáveis em log. Nesse caso, suponha que queremos a variável dependente - y - em log. Para isso, basta fazer <code>log.y &lt;- log(y)</code> e a variável log.y vai ser a versão em log da variável y. Você pode reescrever a regressão como <code>lm(log.y ~ x.1 + x.2 + x.3)</code>.</p>
<p>Agora, pode ocorrer de em alguns casos o vetor y ter algum elemento zero. Mas <span class="math inline">\(\log(0) = -\infty\)</span>. O R tem um elemento Inf (e - Inf) para esses casos, mas o comando lm vai acusar um erro ao receber um vetor com algum elemento Inf. A solução é trocar esse valor para alguma coisa, como um NA, que o R vai ignorar<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>. Para fazer isso, suponha que o vetor com os Inf seja o log.y do paragrafo anterior. Precisamos explicar para o R quais casos nós queremos substituir, e isso é incrivelmente fácil: assim como podemos usar <code>log.y[1]</code> para escolher o primeiro elemento do vetor <code>log.y</code>, podemos colocar entre colchetes uma condição, por exemplo os elementos do vetor log.y que são iguais a infinito. Já tratamos disso: <code>log.y == -Inf</code> faz esse trabalho. Assim, se quisermos substituir os elementos de log.y que são iguais a -Inf por NA, basta usar o seguinte trecho de código:</p>
<pre><code> log.y[log.y == -Inf] &lt;- NA</code></pre>
<p>##Probits e Logits</p>
<p>Probits e logits também são úteis quando nossa variável dependente é uma dummy. Sempre podemos usar um modelo de probabilidade linear, e nesse caso o comando a ser utilizado é o <code>lm</code>. Mas em casos que queremos usar um probit ou logit, precisamos recorrer ao <code>glm</code>, que tem sintaxe muito parecida com o <code>lm</code>. Mas além de especificar as variáveis dependentes e independentes, também precisamos especificar o tipo de regressão, basicamente a distribuição da variável dependente. No caso de probits e logits, a variável dependente tem distribuição binomial. Depois, temos que especificar se a função de probabilidade da variável dependente é probit ou logit. Os comandos para estimar probits e logits são ilustrados abaixo:</p>
<pre><code>mod.1 &lt;- glm(y ~x.1 + x.2 + x.3, family = binomial(link = &#39;probit&#39;))
mod.2 &lt;- glm(y ~x.1 + x.2 + x.3, family = binomial(link = &#39;logit&#39;))</code></pre>
<p>E como de praxe, podemos usar o comando <code>summary</code> para obter os coeficientes, desvios padrões e estatísticas t.</p>
<p>##Variável instrumental</p>
<p>Métodos de variável instrumental são muito úteis e populares, especialmente em casos de endogenidade. Existem várias implementações, mas para o mínimos quadrados de dois estágios usual, o pacote <em>AER</em> oferece um comando <code>ivreg</code>. A sintaxe é similar ao <code>lm</code>, mas com uma alteração na formula para inserir os instrumentos, que são separados dos regressores por |.</p>
<p>Por exemplo, suponha que temos a variável dependente y, as variáveis endogenas x.1 e x.2, a variável exogena x.3, e os instrumentos z.1 e z.2. Nesse caso, o ivreg seria usado:</p>
<pre><code>modelo &lt;- ivreg(y ~x.1 + x.2 + x.3|z.1+z.2+x.3)</code></pre>
<p>E podemos usar o <code>summary</code> para ver o valor dos coeficientes, erros padrão e estatísticas t. Observe que o pacote não mostra o valor do teste F para o primeiro estágio nem de teste de sobre identificação.</p>
<p>##Dados em painel</p>
<p>Em muitas aplicações usamos dados em painel - i.e., com dimensão temporal e cross section. Em geral, esse tipo de aplicação acaba envolvendo o uso de efeitos fixos. Existem duas maneiras de fazer: usando o pacote <em>plm</em> ou “na mão”, usando o lm. Não há nenhuma vantagem de usar o lm “na mão”, em geral, exceto em casos que temos mais de duas dimensões ou por algum motivo o <em>plm</em> não funciona. Exploraremos primeiro o uso do plm, que deve satisfazer a maioria dos usuários. A solução na mão vem depois e pode ser ignorada sem perda de continuidade.</p>
<p>Supondo que o pacote já foi instalado e carregado, precisamos (i) explicar para o pacote quais colunas são as colunas com efeitos fixos de tempo e unidade e (ii) rodar a regressão propriamente dita. Suponha, como de praxe, que temos um dataframe carregado no R com nome “dados”. Suponha que as colunas com as datas e um índice para unidades se chamam datas e unidades, respectivamente. Veja que essas colunas podem estar em formato de carácter, e que isso não deve nos preocupar no momento: poderia ser o caso de a unidade ser estados do país e o código da unidade ser o código do estado (DF,RJ,SP,…). O pacote <em>plm</em> disponibiliza o comando <em>plm.data</em>, que converte um data frame de forma que quando rodarmos a regressão, o R saiba quem são os efeitos fixos. Assim, vamos criar um dataframe chamado <strong>dd</strong>:</p>
<pre><code>dd &lt;- plm.data(dados,c(&#39;unidades&#39;,&#39;datas&#39;))</code></pre>
<p>O primeiro argumento da função é o data.frame a ser convertido, que contém as colunas para as quais criaremos efeitos fixos. O segundo argumento da função são as colunas com os efeitos fixos. Veja que a ordem é unidade e depois a variável temporal. Agora, a estimação do modelo pode ser feita usando o comando plm, que tem sintaxe muito similar ao lm: passamos uma formula com a variável dependente e as independentes, informamos a base de dados - que nesse caso é o objeto <strong>dd</strong>, não o objeto dados. Mas temos algumas novas opções: o método de estimação (em geral estamos interessados em within, o padrão), mas mais relevante é que efeitos fixos queremos colocar: só para indivíduo, só para tempo ou ambos. Abaixo, mostramos a sintaxe para cada um dos casos, respectivamente:</p>
<pre><code>mod.1 &lt;- plm(y ~x.1 + x.2,data = dd, effect = &#39;individual&#39;)
mod.2 &lt;- plm(y ~x.1 + x.2,data = dd, effect = &#39;time&#39;)
mod.3 &lt;- plm(y ~x.1 + x.2,data = dd, effect = &#39;twoways&#39;)</code></pre>
<p>Como de praxe, podemos usar o comando <code>summary</code> para obter um sumário da regressão.</p>
<p>###Painel usando lm*</p>
<p>Suponha que não conseguimos usar o <em>plm</em> por alguma razão. Por exemplo, podemos querer três efeitos fixos: se tivermos microdados de escola, podemos querer ter efeito fixo de aluno, escola e tempo. Podemos implementar isso no braço usando o <code>lm</code>. Lembre-se que, no fundo, efeitos fixos são mera <em>dummies</em>, então se fizermos um modelo linear com dummies, devemos obter resultados parecidos.</p>
<p>Para ficarmos em terreno conhecido, suponha que só temos dois efeitos fixos que nos interessam: unidade e tempo. Cada um desses vem codificado em duas colunas: uma com a data e outra com algum código para a unidade. Lembrem-se da discussão no capítulo anterior que o <code>lm</code> é capaz de usar isso e entender como dummies, sem a necessidade de criar várias variáveis com 0 e 1. Logo, se queremos explicar y usando x como variável explicativa e efeitos fixos de unidade e tempo, a seguinte regressão deve bastar:</p>
<pre><code>modelo &lt;- lm(y ~x +tempo + unidade, data = dados)</code></pre>
<p>E y,x,tempo e unidade estão no dataframe chamado dados, como de praxe. Algumas diferenças devem ser notadas para o comando plm:</p>
<ol class="example" style="list-style-type: decimal">
<li>O sumário vai ser mais confuso no caso do <code>lm</code>: o <code>plm</code> esconde os efeitos fixos, o que não ocorre no caso do <code>lm</code></li>
</ol>
<p>Mas mais importante:</p>
<ol start="2" class="example" style="list-style-type: decimal">
<li>Devido a maneira como o <code>plm</code> estima o modelo (por <em>within</em>, em geral), o <code>plm</code> usa menos graus de liberdade e pode fazer estimações mais precisas. Isso deve impactar mais nos desvios padrões que no valor dos coeficientes, especialmente quando o número de variáveis for muito grande.</li>
</ol>
<table>
<tr>
<th bgcolor="#adadeb">
Hands on!
</th>
</tr>
<tr>
<td bgcolor="#adadeb">
É uma boa hora de checar se os resultados do plm e do lm são de fato similares. O pacote <em>AER</em> traz a base de dados do exemplo de dados em painel sobre cigarros tirado do livro do Stock e Watson. Para carregar, basta digitar <code>data("CigarettesSW")</code>. Os efeitos fixos são para estado e ano, e vem em colunas com nomes state e year, respectivamente. As variável packs nos traz o número de pacotes consumido naquele ano e estado, e income a renda do estado naquele ano. Uma regressão packs em income com efeitos fixos para estado e ano pode ser feita usando os dois métodos da seção anterior: o <code>plm</code> e o <code>lm</code>. Ambos devem dar, aproximadamente, o mesmo valor para o coeficiente do efeito da renda sobre pacotes <span class="math inline">\((-9.070e-08)\)</span>.
</td>
</tr>
</table>

<p>#Séries Temporais</p>
<p>Métodos de séries temporais são suficientemente extensos e únicos para terem seu próprio capítulo. Este capítulo trata dos principais métodos de séries temporais de interesse dos economistas: ARIMAs, VARs, testes de raiz unitária e cointegração. Séries temporais são únicas o suficiente a ponto de terem um classe própria - sem nenhuma surpresa, ela se chama <em>time series</em>.</p>
<p>##O básico</p>
<p>Suponha que você, usando os métodos do capítulo 2, inseriu uma série temporal no R. O R não sabe, <em>a priori</em>, que os dados são uma série temporal. Você precisa contar isso a ele, e o comando que faz isso é o <code>ts()</code>. O <code>ts</code> recebe a série, a data de ínicio e a frequência. A frequência é como você dividiu o ano: 4 se o dado for trimestral, 12 se for mensal…</p>
<p>Por exemplo, podemos gerar uma série de variáveis aleatórias da normal (um ruído branco) e transformar em série temporal mensal começando em janeiro de 2000:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1"></a>serie &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1000</span>)</span>
<span id="cb45-2"><a href="#cb45-2"></a>serie &lt;-<span class="st"> </span><span class="kw">ts</span>(serie,<span class="dt">start =</span><span class="kw">c</span>(<span class="dv">2000</span>,<span class="dv">01</span>), <span class="dt">freq =</span> <span class="dv">12</span>)</span></code></pre></div>
<p>Veja que o comando ts() é excessivamente engessado: os dados tem que ter uma frequência fixa, expressa como uma fração do ano. O pacote <strong>zoo</strong> extende bastante as capacidades do R em lidar com séries temporais, inclusive com séries irregulares.</p>
<p><strong>Atenção: Séries Temporais e o lm</strong>
Você <em>não</em> deve passar um objeto de série temporal para o <code>lm()</code>, já que o <code>lm</code> vai ignorar o formato de série temporal. Assim, estimar um modelo AR(1) usando <code>lm(y ~ lag(y))</code> vai gerar uma regressão com coeficiente 1 para lag(y) e <span class="math inline">\(R^2 = 1\)</span>. De fato, a regressão feita foi y em y - o que não é uma regressão muito emocionante.</p>
<p>##ARIMAs</p>
<p>Com uma série devidamente construída para ser um objeto ts - como nós fizemos acima- podemos tentar estimar algum modelo. O modelo base de séries temporais é o ARIMA. O R base já vem com muitas funções para lidar com isso, mas o pacote <strong>forecast</strong> extende bastante as capacidades do R em lidar com esse tipo de série. O primeiro passo para estimar um modelo Arima é obter a função de autocorrelação (FAC) e a função de autocorrelação parcial (FACP): elas são <code>Acf</code> e <code>Pacf</code>. Veja que existem versões na base do R que se chamam <code>acf</code> e <code>pacf</code> (notem que lá é com maiúscula e aqui com minúscula). A diferença <em>fundamental</em> entre os dois é que a <code>Acf</code> e a <code>acf</code> (e também a <code>Pacf</code> e a <code>pacf</code>) é que a primeira exclui a autocorrelação no momento 0 - que é trivialmente 1.</p>
<p>Uma vez conhecendo o formato da FAC e da FACP, podemos estimar o ARIMA. O comando para estimar um modelo ARIMA é <code>Arima</code> - e novamente, existe um <code>arima</code> com minúscula que é da base do R. O <code>Arima</code> basicamente recebe duas coisas, a série e a ordem do modelo(isso é, se o modelo é um ARMA(1,1), AR(1), MA(1) etc). Vamos gerar um exemplo de um AR(1) com dados simulados e obter a FAC e FACP e estimar o modelo Arma sugerido:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1"></a><span class="kw">library</span>(forecast)</span></code></pre></div>
<pre><code>## Registered S3 method overwritten by &#39;quantmod&#39;:
##   method            from
##   as.zoo.data.frame zoo</code></pre>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1"></a>u &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">500</span>)</span>
<span id="cb48-2"><a href="#cb48-2"></a>y &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">500</span>) <span class="co">#nossa futura série</span></span>
<span id="cb48-3"><a href="#cb48-3"></a></span>
<span id="cb48-4"><a href="#cb48-4"></a>y[<span class="dv">1</span>] &lt;-<span class="st"> </span>u[<span class="dv">1</span>]</span>
<span id="cb48-5"><a href="#cb48-5"></a></span>
<span id="cb48-6"><a href="#cb48-6"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="dv">500</span>){</span>
<span id="cb48-7"><a href="#cb48-7"></a>  y[i] &lt;-<span class="st"> </span><span class="fl">0.6</span><span class="op">*</span>y[i<span class="dv">-1</span>] <span class="op">+</span><span class="st"> </span>u[i] <span class="co">#um AR(1) com coeficiente 0.6</span></span>
<span id="cb48-8"><a href="#cb48-8"></a>}</span>
<span id="cb48-9"><a href="#cb48-9"></a></span>
<span id="cb48-10"><a href="#cb48-10"></a><span class="kw">Acf</span>(y)</span></code></pre></div>
<p><img src="Bookdown_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1"></a><span class="kw">Pacf</span>(y)</span></code></pre></div>
<p><img src="Bookdown_files/figure-html/unnamed-chunk-14-2.png" width="672" /></p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1"></a>modelo &lt;-<span class="st"> </span><span class="kw">Arima</span>(serie,<span class="dt">order=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>))</span>
<span id="cb50-2"><a href="#cb50-2"></a><span class="kw">summary</span>(modelo)</span></code></pre></div>
<pre><code>## Series: serie 
## ARIMA(1,0,0) with non-zero mean 
## 
## Coefficients:
##           ar1     mean
##       -0.0312  -0.0157
## s.e.   0.0316   0.0315
## 
## sigma^2 estimated as 1.06:  log likelihood=-1447.14
## AIC=2900.28   AICc=2900.31   BIC=2915
## 
## Training set error measures:
##                        ME     RMSE       MAE    MPE     MAPE      MASE
## Training set 1.500234e-05 1.028603 0.8091188 98.585 111.1065 0.7103052
##                       ACF1
## Training set -0.0002764195</code></pre>
<p>Veja que o objeto <code>modelo</code> trás os coeficientes estimados, o erro padrão e alguns diagnósticos úteis como critérios de informação.</p>
<p>Em algumas situações pode ser muito difícil inferir o modelo certo a partir da FAC e da FACP. O comando <code>auto.arima</code>, do pacote <strong>forecast</strong>, seleciona um modelo a partir de algum critério de informação. Vamos ilustrar o ponto gerando uma série <code>x</code> que é um ARMA(1,2):</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1"></a>e &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1000</span>)</span>
<span id="cb52-2"><a href="#cb52-2"></a></span>
<span id="cb52-3"><a href="#cb52-3"></a>x &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">1000</span>)</span>
<span id="cb52-4"><a href="#cb52-4"></a></span>
<span id="cb52-5"><a href="#cb52-5"></a><span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">998</span>){</span>
<span id="cb52-6"><a href="#cb52-6"></a>  x[j<span class="op">+</span><span class="dv">2</span>] &lt;-<span class="st"> </span><span class="fl">0.5</span><span class="op">*</span>x[j<span class="op">+</span><span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>e[j<span class="op">+</span><span class="dv">2</span>] <span class="op">-</span><span class="st"> </span><span class="fl">0.3</span><span class="op">*</span>e[j<span class="op">+</span><span class="dv">1</span>] <span class="op">+</span><span class="st"> </span><span class="fl">0.4</span><span class="op">*</span>e[j]</span>
<span id="cb52-7"><a href="#cb52-7"></a>}</span>
<span id="cb52-8"><a href="#cb52-8"></a></span>
<span id="cb52-9"><a href="#cb52-9"></a>x &lt;-<span class="st"> </span>x[<span class="dv">500</span><span class="op">:</span><span class="dv">1000</span>]</span>
<span id="cb52-10"><a href="#cb52-10"></a>x &lt;-<span class="st"> </span><span class="kw">ts</span>(x, <span class="dt">start =</span> <span class="kw">c</span>(<span class="dv">1999</span>,<span class="dv">05</span>), <span class="dt">freq =</span> <span class="dv">12</span>)</span>
<span id="cb52-11"><a href="#cb52-11"></a></span>
<span id="cb52-12"><a href="#cb52-12"></a><span class="kw">Acf</span>(x)</span></code></pre></div>
<p><img src="Bookdown_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1"></a><span class="kw">Pacf</span>(x)</span></code></pre></div>
<p><img src="Bookdown_files/figure-html/unnamed-chunk-15-2.png" width="672" /></p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1"></a><span class="kw">auto.arima</span>(x,<span class="dt">ic =</span> <span class="st">&quot;bic&quot;</span>)</span></code></pre></div>
<pre><code>## Series: x 
## ARIMA(1,0,2)(1,0,0)[12] with zero mean 
## 
## Coefficients:
##          ar1      ma1     ma2     sar1
##       0.4648  -0.2850  0.4401  -0.0243
## s.e.  0.0766   0.0738  0.0418   0.0455
## 
## sigma^2 estimated as 0.8746:  log likelihood=-675.65
## AIC=1361.29   AICc=1361.41   BIC=1382.37</code></pre>
<p>Nesse caso o <code>auto.arima</code> acertou, mas nem sempre isso ocorre.</p>
<p>##VARs</p>
<p>Um VAR, teoricamente, é apenas uma generalização do AR. Ainda assim, do ponto de vista computacional, eles são distintos, e o VAR tem seu próprio conjunto de pacotes no R. O mais importante deles é o <code>vars</code>.</p>
<p>Começamos juntando todas as séries que queremos estimar o VAR em uma matriz (use o cbind() para isso). O passo seguinte é escolher a ordem do VAR - geralmente usando algum critério de informação. O comando <code>VARselect</code> faz isso e apresenta alguns critérios de informação e a quantidade de lags que minimizam cada um.</p>
<p>O comando que faz a estimativa per se é o <code>VAR</code>. Ele recebe a matriz com as séries e quantos lags você quer que sejam usados - ou o critério de informação a ser usado na hora de fazer a estimativa.</p>
<p>Por último, queremos recuperar a resposta dinâmica de cada uma das variáveis a um choque (não só um choque na própria variável, como o efeito cruzado de um choque em outra variável).</p>
<p>Vamos gerar um VAR(1) com duas variáveis apenas para ilustrar o uso do pacote:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1"></a><span class="kw">library</span>(vars)</span></code></pre></div>
<pre><code>## Loading required package: MASS</code></pre>
<pre><code>## Loading required package: strucchange</code></pre>
<pre><code>## Loading required package: zoo</code></pre>
<pre><code>## 
## Attaching package: &#39;zoo&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:base&#39;:
## 
##     as.Date, as.Date.numeric</code></pre>
<pre><code>## Loading required package: sandwich</code></pre>
<pre><code>## Loading required package: urca</code></pre>
<pre><code>## Loading required package: lmtest</code></pre>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1"></a>T &lt;-<span class="st"> </span><span class="dv">500</span> <span class="co">#número de períodos</span></span>
<span id="cb65-2"><a href="#cb65-2"></a>N &lt;-<span class="st"> </span><span class="dv">2</span> <span class="co">#número de variáveis</span></span>
<span id="cb65-3"><a href="#cb65-3"></a></span>
<span id="cb65-4"><a href="#cb65-4"></a>u &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(T<span class="op">*</span>N),<span class="dt">nrow =</span> N,<span class="dt">ncol =</span> T)</span>
<span id="cb65-5"><a href="#cb65-5"></a></span>
<span id="cb65-6"><a href="#cb65-6"></a>x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">nrow =</span> N, <span class="dt">ncol =</span> T)</span>
<span id="cb65-7"><a href="#cb65-7"></a></span>
<span id="cb65-8"><a href="#cb65-8"></a>A &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="fl">0.3</span>,<span class="op">-</span><span class="fl">0.2</span>),<span class="kw">c</span>(<span class="fl">0.6</span>,<span class="fl">0.2</span>))</span>
<span id="cb65-9"><a href="#cb65-9"></a></span>
<span id="cb65-10"><a href="#cb65-10"></a><span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>T){</span>
<span id="cb65-11"><a href="#cb65-11"></a>  x[,j] &lt;-<span class="st"> </span>A<span class="op">%*%</span>x[,j<span class="dv">-1</span>] <span class="op">+</span><span class="st"> </span>u[,j]</span>
<span id="cb65-12"><a href="#cb65-12"></a>}</span>
<span id="cb65-13"><a href="#cb65-13"></a></span>
<span id="cb65-14"><a href="#cb65-14"></a>x &lt;-<span class="st"> </span>x[,<span class="dv">400</span><span class="op">:</span><span class="dv">500</span>]</span>
<span id="cb65-15"><a href="#cb65-15"></a>x &lt;-<span class="st"> </span><span class="kw">t</span>(x)</span>
<span id="cb65-16"><a href="#cb65-16"></a><span class="kw">colnames</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>)</span>
<span id="cb65-17"><a href="#cb65-17"></a></span>
<span id="cb65-18"><a href="#cb65-18"></a><span class="kw">VARselect</span>(x) </span></code></pre></div>
<pre><code>## $selection
## AIC(n)  HQ(n)  SC(n) FPE(n) 
##      1      1      1      1 
## 
## $criteria
##                1         2         3         4         5        6         7
## AIC(n) 0.5073838 0.5664775 0.6364448 0.7148971 0.8004834 0.804686 0.8853781
## HQ(n)  0.5741733 0.6777934 0.7922872 0.9152658 1.0453785 1.094108 1.2193260
## SC(n)  0.6729349 0.8423961 1.0227309 1.2115506 1.4075043 1.522074 1.7131339
## FPE(n) 1.6610195 1.7624397 1.8909018 2.0466301 2.2319134 2.244812 2.4386605
##                8         9        10
## AIC(n) 0.9301667 0.9188877 0.9939262
## HQ(n)  1.3086411 1.3418885 1.4614533
## SC(n)  1.8682901 1.9673785 2.1527844
## FPE(n) 2.5575410 2.5379366 2.7479537</code></pre>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1"></a>modelo &lt;-<span class="st"> </span><span class="kw">VAR</span>(x,<span class="dt">p =</span> <span class="dv">1</span>)</span>
<span id="cb67-2"><a href="#cb67-2"></a><span class="kw">plot</span>(<span class="kw">irf</span>(modelo, <span class="dt">impulse =</span> <span class="st">&quot;x&quot;</span>, <span class="dt">response =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>)))</span></code></pre></div>
<p><img src="Bookdown_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>Eu só pedi o plot do choque da primeira variável sobre as duas variáveis por que isso é uma ilustração. Fazer <code>plot(irf(modelo))</code> em uma seção do R, ele vai plotar os choques de todas as variáveis sobre todas as variáveis.</p>
<p>##Raiz unitária</p>
<p>O pacote <strong>urca</strong> nos trás testes de raiz unitária. O teste Dickey-Fuller, um dos mais populares, é chamado pelo <code>ur.df()</code>. Vamos gerar um passeio aleatório para mostrar:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1"></a> x &lt;-<span class="st"> </span><span class="kw">cumsum</span>(<span class="kw">rnorm</span>(<span class="dv">1000</span>))</span>
<span id="cb68-2"><a href="#cb68-2"></a><span class="kw">summary</span>(<span class="kw">ur.df</span>(x))</span></code></pre></div>
<pre><code>## 
## ############################################### 
## # Augmented Dickey-Fuller Test Unit Root Test # 
## ############################################### 
## 
## Test regression none 
## 
## 
## Call:
## lm(formula = z.diff ~ z.lag.1 - 1 + z.diff.lag)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -3.0769 -0.7404 -0.0143  0.6389  3.4537 
## 
## Coefficients:
##              Estimate Std. Error t value Pr(&gt;|t|)
## z.lag.1    -2.254e-05  7.896e-04  -0.029    0.977
## z.diff.lag -1.212e-02  3.169e-02  -0.383    0.702
## 
## Residual standard error: 1.001 on 996 degrees of freedom
## Multiple R-squared:  0.0001483,  Adjusted R-squared:  -0.001859 
## F-statistic: 0.07388 on 2 and 996 DF,  p-value: 0.9288
## 
## 
## Value of test-statistic is: -0.0285 
## 
## Critical values for test statistics: 
##       1pct  5pct 10pct
## tau1 -2.58 -1.95 -1.62</code></pre>
<p>Veja que o valor crítico para o teste Dick Fuller não é o valor usual da estatística t, mas sim o valor exibido na parte debaixo da tabela do sumário do teste. Nesse caso, a qualquer nível de significância, nós não rejeitamos a hipótese de raiz unitária. Vamos testar para um caso estacionário:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1"></a>u &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">2000</span>)</span>
<span id="cb70-2"><a href="#cb70-2"></a>y &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">2000</span>)</span>
<span id="cb70-3"><a href="#cb70-3"></a></span>
<span id="cb70-4"><a href="#cb70-4"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="dv">2000</span>){</span>
<span id="cb70-5"><a href="#cb70-5"></a>  y[i] &lt;-<span class="st"> </span><span class="fl">0.5</span><span class="op">*</span>y[i<span class="dv">-1</span>] <span class="op">+</span><span class="st"> </span>u[i]</span>
<span id="cb70-6"><a href="#cb70-6"></a>}</span>
<span id="cb70-7"><a href="#cb70-7"></a></span>
<span id="cb70-8"><a href="#cb70-8"></a>y &lt;-<span class="st"> </span>y[<span class="dv">1000</span><span class="op">:</span><span class="dv">2000</span>]</span>
<span id="cb70-9"><a href="#cb70-9"></a></span>
<span id="cb70-10"><a href="#cb70-10"></a><span class="kw">summary</span>(<span class="kw">ur.df</span>(y))</span></code></pre></div>
<pre><code>## 
## ############################################### 
## # Augmented Dickey-Fuller Test Unit Root Test # 
## ############################################### 
## 
## Test regression none 
## 
## 
## Call:
## lm(formula = z.diff ~ z.lag.1 - 1 + z.diff.lag)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -3.7812 -0.6434  0.0092  0.6571  3.2324 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## z.lag.1    -0.501212   0.031742 -15.790   &lt;2e-16 ***
## z.diff.lag -0.002658   0.031612  -0.084    0.933    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.9926 on 997 degrees of freedom
## Multiple R-squared:  0.2511, Adjusted R-squared:  0.2496 
## F-statistic: 167.1 on 2 and 997 DF,  p-value: &lt; 2.2e-16
## 
## 
## Value of test-statistic is: -15.7901 
## 
## Critical values for test statistics: 
##       1pct  5pct 10pct
## tau1 -2.58 -1.95 -1.62</code></pre>
<p>##Desassonalizando</p>
<p>Dados de séries temporais, não raramente, apresentam sazonalidade. Por exemplo, gasto de energia elétrica tende a ser maior nos meses de dezembro a fevereiro, devido ao verão. Retirar sazonalidade é importante em muitas análises.</p>
<p>Um método padrão é colocar <em>dummies</em> para as unidades de tempo (uma para cada mês se o dado for mensal, uma para cada trimestre se for trimestral etc) e usar o <em>resíduo</em> dessa regressão somado a média da série (já que o resíduo tem média zero, por construção). Criar as <em>dummies</em> “no braço” pode ser tedioso, mas felizmente o pacote <strong>forecast</strong> trás o comando <code>seasonaldummy()</code> que cria as <em>dummies</em> automaticamente para a série.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1"></a>energia &lt;-<span class="st"> </span><span class="kw">BETSget</span>(<span class="dv">1406</span>, <span class="dt">from =</span> <span class="st">&quot;2002-01-01&quot;</span>)</span>
<span id="cb72-2"><a href="#cb72-2"></a>dum &lt;-<span class="st"> </span><span class="kw">seasonaldummy</span>(energia)</span>
<span id="cb72-3"><a href="#cb72-3"></a>mod &lt;-<span class="st"> </span><span class="kw">Arima</span>(energia, <span class="dt">xreg =</span> dum)</span>
<span id="cb72-4"><a href="#cb72-4"></a>des &lt;-<span class="st"> </span><span class="kw">resid</span>(mod) <span class="op">+</span><span class="st"> </span><span class="kw">mean</span>(energia)</span>
<span id="cb72-5"><a href="#cb72-5"></a><span class="kw">plot</span>(energia)</span>
<span id="cb72-6"><a href="#cb72-6"></a><span class="kw">lines</span>(des, <span class="dt">col =</span> <span class="dv">2</span>)</span>
<span id="cb72-7"><a href="#cb72-7"></a><span class="kw">legend</span>(<span class="st">&quot;topleft&quot;</span>, <span class="dt">legend =</span> <span class="kw">c</span>(<span class="st">&quot;C/Sazonalidade&quot;</span>, <span class="st">&quot;Sem Sazonalidade&quot;</span>), <span class="dt">lty =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="dt">col =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span></code></pre></div>
<p><img src="Bookdown_files/figure-html/desazonalizando-1.png" width="672" /></p>
<p>Outra maneira comum de dessazonalizar é usando o X13, um programa do governo americano. O X13 pode ser acessado direto do R usando o pacote <strong>seasonal</strong>. O comando que acessa o X13 é o <code>seas</code>. O X13 são, na verdade, <em>dois</em> programas: um que é o X13 e o outro que é o SEATS. Ambos tem a mesma função: dessazonalizar. O X13 vem com todo tipo de método automático para detectar outliers, fazer transformações nas séries e uma infinidade de outras coisas. Nesse caso, nós vamos desligar todas essa opções:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1"></a><span class="kw">library</span>(seasonal)</span>
<span id="cb73-2"><a href="#cb73-2"></a>modelo2 &lt;-<span class="st"> </span><span class="kw">seas</span>(energia, <span class="dt">transform.function =</span> <span class="st">&quot;none&quot;</span>, <span class="dt">regression.aictest =</span> <span class="ot">NULL</span>, <span class="dt">outlier =</span> <span class="ot">NULL</span>)</span></code></pre></div>
<p>O comando <code>final</code> obtém a série dessazonalizada:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1"></a><span class="kw">plot</span>(energia)</span>
<span id="cb74-2"><a href="#cb74-2"></a><span class="kw">lines</span>(<span class="kw">final</span>(modelo2), <span class="dt">col =</span> <span class="dv">2</span>)</span>
<span id="cb74-3"><a href="#cb74-3"></a><span class="kw">legend</span>(<span class="st">&quot;topleft&quot;</span>, <span class="dt">legend =</span> <span class="kw">c</span>(<span class="st">&quot;C/Sazonalidade&quot;</span>, <span class="st">&quot;Sem Sazonalidade&quot;</span>), <span class="dt">lty =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="dt">col =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span></code></pre></div>
<p><img src="Bookdown_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<p>##Filtro Hodrick-Prescott</p>
<p>O filtro Hodrick-Prescott (HP) é utilizado em séries não estacionárias quando queremos separar a tendência do componente ciclíco. Ele é polêmico, mas ainda é amplamente usado. No R, o pacote <strong>mFilter</strong> implementa ele e alguns outros. Vamos aplicar na série de energia:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1"></a><span class="kw">library</span>(mFilter)</span>
<span id="cb75-2"><a href="#cb75-2"></a>filtrado &lt;-<span class="st"> </span><span class="kw">mFilter</span>(energia, <span class="st">&quot;HP&quot;</span>)</span>
<span id="cb75-3"><a href="#cb75-3"></a><span class="kw">plot</span>(filtrado)</span></code></pre></div>
<p><img src="Bookdown_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p>Eu posso acessar a tendência e o componente cíclico usando o <code>filtrado$trend</code> e <code>filtrado$cycle</code>, no exemplo acima - que seria particularmente útil se eu quisesse utilizar os dados de cíclo para alguma estimação.</p>

<p>#Apresentando os resultados</p>
<p>Os milhares de modelos que você rodou são tão úteis quanto a sua capacidade de apresentar eles. Sem sermos capazes de apresentar os resultados, nosso trabalho é estéril. Este capítulo apresenta algumas maneiras de usar o R para apresentar resultados.</p>
<p>##Tabelas</p>
<p>Feitas as regressões, precisamos apesentar os resultados. Você sempre pode copiar e colar o sumário do R, mas convenhamos: ele é feio. Podemos digitar na mão, mas isto é trabalhoso. A boa notícia é que alguns pacotes do R ajudam ao criar tabelas. Damos atenção a dois: o <strong>stargazer</strong> e o <strong>xtable</strong>.</p>
<p>A má notícia é que esses dois pacotes não geram tabelas para o Word. Eles geram tabelas para LaTeX e para html. LaTeX é uma linguagem muito popular para escrever artigos científicos e livros - este manual foi, originalmente, escrito em LaTeX; já html é a linguagem padrão para criar sites na internet, e é a base do Markdown, apresentado na próxima seção. O que vemos nos documentos como esse e como sites da internet são as versões compiladas. Tanto html, Markdown e LaTeX não são como o Word, que o que você vê é como vai ficar no documento final: ambas são, de certa forma, linguagens de programação para produzir textos. Há um comando para colocar as palavras em negrito, outro para itálico etc.</p>
<p>Explicar como usar o LaTeX foge do escopo deste manual. Entretanto, o autor incentiva que o leitor aprenda LaTeX ou Markdown. O Markdown, que vai ser apresentado com mais detalhes na próxima seção, é um passo intermediário entre o R e o LaTeX, e pode facilitar imensamente o aprendizado do LaTeX. Alguns motivos para aprender LaTeX (e Markdown) é que (1) é mais fácil digitar equações, (2) fácil de integrar com o R, (3) uma vez que você aprende, é mais fácil que o Word, (4) os documentos em LaTeX são mais bonitos que os efeitos em Word. As referências no fim do manual trazem alguns links para os interessados em aprender LaTeX.</p>
<p>O <strong>xtable</strong> converte tabelas do R para o formato LaTeX. Se você tem uma matriz de nome <code>matriz</code> e fizer <code>xtable(matriz)</code>, o R vai fornecer o código em LaTeX para fazer uma tabela com os elementos da <code>matriz</code>. Já o <strong>stargazer</strong> apresenta o sumário da regressão em formato LaTeX (ou html) automaticamente. Suponha que você tenha um modelo chamado <code>modelo</code>. Usar <code>stargazer(modelo)</code> vai apresentar o sumário do modelo. O comando é altamente configurável, com uma infinidade de parâmetros; e funciona com vários pacotes e não só com comandos da base do R, como o <code>lm</code>.</p>
<p>##Markdown</p>
<p>O Rstudio já vem com uma opção para trabalhar com arquivos markdown, e para criar um novo arquivo markdown basta ir no menu, new file, R Markdown. O R Markdown também depende de comandos para fazer as alterações no texto - por exemplo, itálico são asteriscos cercando o texto. Assim, se digitarmos no markdown <code>*itálico*</code>, o resultado final seria <em>itálico</em>. Isso pode parecer esquisito a primeira vista, mas uma vez criado o hábito, o comportamento é bem mais previsível que o word.</p>
<p>O Markdown é mais fácil de usar que o LaTeX, mas tem menos opções. O Rstudio tem várias dicas de como usar o Markdown - basta olhar o help do Rstudio, ir na opção cheatsheets, e temos duas opções: R Markdown Cheatsheet e R Markdown Reference Guide. Ambos são úteis. Também no help temos o Markdown Quick Reference, que tem os principais comandos para o Markdown, e que abre na mesma janela que o help do R.</p>
<p>Veja que ao criar um novo arquivo, ele dá várias opções: html, pdf, word. Se você escolher html, pode gerar um pdf ou arquivo word depois, <em>mas não o contrário</em>. Logo, escolha o html. Se você não fez nenhuma alteração na organização do RStudio, ele deve abrir em cima do console. Há várias opções na barra abaixo do nome do arquivo e a mais importante é o Knit: ele vai gerar o documento que você quer ver. Na primeira vez que você clicar nele, você vai ter que salvar o arquivo: dê um nome e não esqueça de colocar a extensão .Rmd. Assim, se o arquivo se chama relatório, você deve salvar como relatorio.Rmd<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>. Se tudo der certo, o R vai abrir o novo arquivo, devidamente formatado. Ele terá o mesmo nome que o arquivo que você salvou. Assim, você terá dois arquivos: o .Rmd e o .html - assim como, quando geramos um pdf a partir do word, temos um arquivo .docx e um .pdf. A ideia é a mesma: é possível editar o .Rmd e gerar o html a partir dele. Veja que é possível que ele dê algum erro - exatamente como quando rodamos um programa no R.</p>
<p>A parte mais interessante do Markdown é que é possível colocar pedaços de código do R (e até mesmo de outras linguagens) no meio do texto, e o Markdown vai “dar” esse pedaço de código para o R rodar e reportar o resultado. Veja o help do Markdown sobre como fazer isso. Apesar de ser uma possibilidade interessante, ela pode ser problemática: se algum pedaço do seu código demorar muito para rodar, toda vez que ocê der Knit o código vai ser rodado. A opção <code>cache = TRUE</code> no bloco deve amenizar isso.</p>
<p>##Gráficos</p>
<p>Outra ferramenta fundamental para apresentar resultados são gráficos. O R tem um pacote padrão para gráficos e um pacote extra amplamente usado chamado <strong>ggplot2</strong>. Neste manual não irei tratar do <strong>ggplot2</strong>: o R Studio tem um help excelente que introduz o uso do <strong>ggplot2</strong>.</p>
<p>Os gráficos do R são feitos em camadas: a primeira camada é feita com o comando <code>plot</code>; para adicionar novas coisas na mesma imagem, existe uma série de outros comandos. Usar o <code>plot</code> de novo vai gerar uma nova imagem.</p>
<p>Em geral, o <code>plot</code> recebe qual(is) série(s) serão exibidas. Você pode passar uma única série, que será <em>plotada</em> no eixo y, e o eixo x será apenas o número da observação; ou x e y, e o gráfico vai mostrar os pontos com coordenadas (x,y). Cada um dos casos, respectivamente:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1"></a>x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">100</span>) <span class="co">#Gerando alguns números de uma normal</span></span>
<span id="cb76-2"><a href="#cb76-2"></a>y &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">*</span>x<span class="op">+</span><span class="kw">rnorm</span>(<span class="dv">100</span>) <span class="co">#y é uma função de x com algum erro adicionado</span></span>
<span id="cb76-3"><a href="#cb76-3"></a><span class="kw">plot</span>(y)</span></code></pre></div>
<p><img src="Bookdown_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1"></a><span class="kw">plot</span>(x,y)</span></code></pre></div>
<p><img src="Bookdown_files/figure-html/unnamed-chunk-22-2.png" width="672" /></p>
<p>O comando <strong>plot</strong> tem uma opção especial chamada <strong>type</strong>. Aqui você pode escolher como os dados são <em>plotados</em>: em pontos, em linhas ou diversas outras opções descritas no help. O padrão é pontos. Em geral, se passa a primeira letra de cada tipo. Assim, para fazer o gráfico de linha da variável y, basta usar <code>plot(y, type=''l'')</code>:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1"></a><span class="kw">plot</span>(y,<span class="dt">type=</span><span class="st">&quot;l&quot;</span>)</span></code></pre></div>
<p><img src="Bookdown_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<p>Existem vários comandos para colocar novos objetos sobre o gráfico, mas vou me limitar a dois: <code>points</code> e <code>lines</code>, que adicionam respectivamente… pontos e linhas. Em geral, <code>plot,lines</code> e <code>points</code> recebem argumentos parecidos:</p>
<ul>
<li><strong>col</strong> específica a cor. Em geral, se usa números: 1 é preto, 2 é vermelho…</li>
<li><strong>lty</strong> específica o tipo da linha: logo, é inútil para o comando <code>points</code> ou <code>plot</code> sem type=“l”. Também usamos números: 1 é a linha sólida, 2 é a linha tracejada…</li>
<li><strong>pch</strong> é a contraparte do lty para pontos e permite escolher qual o tipo de ponto que será usado no comando <code>points</code> ou no <code>plot</code> com opção type = “p”. Também se usa números para especificar como serão os pontos</li>
</ul>
<p>Cada comando gráfico tem suas particularidades e uma visita ao help de cada um deles é sempre necessária para o autor deste manual.</p>

<p>#Ifs, Fors, Whiles</p>
<p>Todas as linguagens de programação usam <em>ifs, fors</em> e <em>whiles</em>, que sempre fazem a mesma coisa em linhas gerais. Este capítulo trata deles. Cada seção vai tratar de cada um deles, e todas serão estruturadas da seguinte maneira: primeiramente, só apresentamos a sintaxe dos comandos no R. A seguir, temos uma discussão sobre o que cada estrutura faz. Desta maneira, aqueles que já conhecem essas estruturas de outras linguagens podem simplesmente ler a sintaxe e pular toda a discussão subsequente.</p>
<p>Em geral, os exemplos podem não parecer ter utilidade prática, mas servem para entender as ideias. Aplicações práticas são encontradas nos capítulos subsequentes.</p>
<p>##If</p>
<p><em>Ifs</em> são estruturas condicionais: se essa condição é atendida, faça isso. Senão, faça aquilo outro. A sintaxe é:</p>
<pre><code>if(condição){
    ação se a condição for atendida} else {
    ação se a condição não for atendida}</code></pre>
<p>Por exemplo, podemos escrever um código que testa se <span class="math inline">\(x\)</span> - que deve ser um número - é igual a 18, e se sim ele nos mostra um “Sim”. Caso contrário, “Não”.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1"></a>x &lt;-<span class="st"> </span><span class="dv">18</span></span>
<span id="cb80-2"><a href="#cb80-2"></a><span class="cf">if</span>(x<span class="op">==</span><span class="dv">18</span>){</span>
<span id="cb80-3"><a href="#cb80-3"></a>    <span class="kw">print</span>(<span class="st">&quot;Sim&quot;</span>)} <span class="cf">else</span> {</span>
<span id="cb80-4"><a href="#cb80-4"></a>    <span class="kw">print</span>(<span class="st">&quot;Não&quot;</span>)}</span></code></pre></div>
<pre><code>## [1] &quot;Sim&quot;</code></pre>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1"></a>x &lt;-<span class="st"> </span><span class="dv">21</span></span>
<span id="cb82-2"><a href="#cb82-2"></a><span class="cf">if</span>(x<span class="op">==</span><span class="dv">18</span>){</span>
<span id="cb82-3"><a href="#cb82-3"></a>    <span class="kw">print</span>(<span class="st">&quot;Sim&quot;</span>)} <span class="cf">else</span> {</span>
<span id="cb82-4"><a href="#cb82-4"></a>    <span class="kw">print</span>(<span class="st">&quot;Não&quot;</span>)}</span></code></pre></div>
<pre><code>## [1] &quot;Não&quot;</code></pre>
<p>Podemos concatenar vários else e ifs e testar várias condições. Podemos querer saber se x é menor que 5 ou maior que 7:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1"></a>x &lt;-<span class="st"> </span><span class="dv">5</span></span>
<span id="cb84-2"><a href="#cb84-2"></a><span class="cf">if</span>(x <span class="op">&lt;</span><span class="st"> </span><span class="dv">5</span>){</span>
<span id="cb84-3"><a href="#cb84-3"></a>    <span class="kw">print</span>(<span class="st">&quot;Menor que 5&quot;</span>)} <span class="cf">else</span> <span class="cf">if</span>(x <span class="op">&gt;</span><span class="st"> </span><span class="dv">7</span>){</span>
<span id="cb84-4"><a href="#cb84-4"></a>    <span class="kw">print</span>(<span class="st">&quot;Maior que 7&quot;</span>)} <span class="cf">else</span> {</span>
<span id="cb84-5"><a href="#cb84-5"></a>    <span class="kw">print</span>(<span class="st">&quot;Nenhum dos dois&quot;</span>)}</span></code></pre></div>
<pre><code>## [1] &quot;Nenhum dos dois&quot;</code></pre>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1"></a>x &lt;-<span class="st"> </span><span class="dv">8</span></span>
<span id="cb86-2"><a href="#cb86-2"></a><span class="cf">if</span>(x <span class="op">&lt;</span><span class="st"> </span><span class="dv">5</span>){</span>
<span id="cb86-3"><a href="#cb86-3"></a>    <span class="kw">print</span>(<span class="st">&quot;Menor que 5&quot;</span>)} <span class="cf">else</span> <span class="cf">if</span>(x <span class="op">&gt;</span><span class="st"> </span><span class="dv">7</span>){</span>
<span id="cb86-4"><a href="#cb86-4"></a>    <span class="kw">print</span>(<span class="st">&quot;Maior que 7&quot;</span>)} <span class="cf">else</span> {</span>
<span id="cb86-5"><a href="#cb86-5"></a>    <span class="kw">print</span>(<span class="st">&quot;Nenhum dos dois&quot;</span>)}</span></code></pre></div>
<pre><code>## [1] &quot;Maior que 7&quot;</code></pre>
<p>Essa estrutura pode ser chata e requerer muitas linhas quando queremos algo simples. Pense no caso que queremos definir a variável h como 1 se x é maior que 1, e 0 caso contrário. Felizmente, o comando <code>ifelse</code> resolve isso. A sintaxe dele é simples: a condição, o valor se a condição for atendida e o valor se a condição não for atendida. Assim, no exemplo acima:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1"></a>h &lt;-<span class="st"> </span><span class="kw">ifelse</span>(x <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span> ,<span class="dv">1</span>,<span class="dv">0</span>)</span>
<span id="cb88-2"><a href="#cb88-2"></a>h</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>Entretanto, em muitas situações, usar a estrutura do if ao invés da função <code>ifelse()</code> é útil.</p>
<p>##For e While</p>
<p><em>For</em> (e <em>whiles</em>) são <em>loops</em>: eles permitem repetir a mesma operação várias vezes. Para eles serem interessantes, eles tem que permitir alguma alteração no input e no output. A sintaxe do for é:</p>
<pre><code>for(i in 1:n){
ações...
}</code></pre>
<p>Veja que podemos indexar o for por qualquer letra (e não apenas i), e que podemos usar um vetor para indexar o for, o que vai fazer o for repetir a operação pelo comprimento daquele vetor - e definir o valor de i como o valor dos elementos do vetor. Por exemplo:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb91-1"><a href="#cb91-1"></a>a &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>)</span>
<span id="cb91-2"><a href="#cb91-2"></a>b &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb91-3"><a href="#cb91-3"></a></span>
<span id="cb91-4"><a href="#cb91-4"></a><span class="cf">for</span>(i <span class="cf">in</span> a){</span>
<span id="cb91-5"><a href="#cb91-5"></a>b &lt;-<span class="st"> </span>b <span class="op">+</span><span class="st"> </span>i</span>
<span id="cb91-6"><a href="#cb91-6"></a><span class="kw">print</span>(b)</span>
<span id="cb91-7"><a href="#cb91-7"></a>}</span></code></pre></div>
<pre><code>## [1] 1
## [1] 3
## [1] 6
## [1] 10
## [1] 15</code></pre>
<table>
<tr>
<th bgcolor="#adadeb">
Hands on!
</th>
</tr>
<tr>
<td bgcolor="#adadeb">
<p>Podemos usar o <em>for</em> para ilustrar uma ideia bastante importante de estatística: a lei dos grandes números. Para refrescar a memória: a lei dos grandes números diz que se a variável aleatória tem média <span class="math inline">\(\mu\)</span>, <span class="math inline">\(\bar{X}\)</span> é a média amostral e <span class="math inline">\(n\)</span> é o tamanho da amostra, então <span class="math inline">\(\text{plim}_{n \rightarrow \infty}(\bar{X}) = \mu\)</span>. O código para ilustrar isso é simples:</p>
<ul>
<li>Gere um vetor de variáveis aleatórias retirados de alguma distribuição (por exemplo, <code>rnorm(200)</code>). Vamos chamar esse vetor de <code>amostra</code>.</li>
<li>Crie um vetor de zeros (você pode fazer isso usando <code>rep(0,200)</code>) Chame ele de alguma coisa. No caso, chamarei ele de <code>media</code></li>
<li>Crie um loop que faz com que cada posição do vetor <code>media</code> seja a média dos números em <code>amostra</code> até aquela posição. Assim, se tivermos na 4ª posição de <code>media</code>, teremos a média dos números da <code>amostra</code> de 1 a 4.</li>
</ul>
Plot o vetor <code>media</code>: ele deve se aproximar da media verdadeira do processo conforme n cresce. Você pode testar <span class="math inline">\(n\)</span> diferente de 200 para ver o quão bom fica a aproximação, bem como diferentes distribuições e parâmetros.
</td>
</tr>
</table>
<p>O <em>while</em> funciona de maneira parecida, mas ao invés de ir até o fim do contador, o while depende de alguma condição. O exemplo mais usual é um while que acaba quando uma variável alcança um certo valor. Por exemplo:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb93-1"><a href="#cb93-1"></a>b &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb93-2"><a href="#cb93-2"></a>j &lt;-<span class="st"> </span><span class="dv">1</span></span>
<span id="cb93-3"><a href="#cb93-3"></a></span>
<span id="cb93-4"><a href="#cb93-4"></a><span class="cf">while</span>(j <span class="op">&lt;</span><span class="st"> </span><span class="dv">6</span>){</span>
<span id="cb93-5"><a href="#cb93-5"></a>b &lt;-<span class="st"> </span>b <span class="op">+</span><span class="st"> </span>j</span>
<span id="cb93-6"><a href="#cb93-6"></a>j &lt;-<span class="st"> </span>j <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb93-7"><a href="#cb93-7"></a>}</span></code></pre></div>
<p>Esse exemplo faz exatamente a mesma coisa que o <em>for</em> anterior. Observe que <strong>temos que adicionar a linha</strong> <code>j &lt;- j +1</code>, senão j nunca irá alcançar 6, e o R nunca vai sair do while: ele vai ver <span class="math inline">\(j = 1\)</span> e continuar no while infinitamente. Também observe que temos que criar o <code>j &lt;- 1</code>, enquanto no <em>for</em> não havia a necessidade de criar a variável i de antemão.</p>
<p>##Diferenças e Semelhanças entre for e while</p>
<p>O exemplo anterior de <em>while</em> deixa claro que ele é muito semelhante ao <em>for</em>: ambos permitem repetir um conjunto de operações um certo número de vezes. A inclusão do <em>while</em> parece até um desperdício: uma função quase idêntica ao for que exige duas linhas de código a mais. Mas enquanto muitas vezes o <em>for</em> é mais usado que o <em>while</em>, o <em>while</em> tem suas vantagens, como o seguinte exemplo ilustra.</p>
<p>Suponha que queremos gerar 100 matrizes de 100 observações com 10 variáveis independentes de uma normal e queremos garantir que a matriz seja invertível<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>. Poderíamos escrever:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1"></a>matrizes &lt;-<span class="st"> </span><span class="kw">list</span>()</span>
<span id="cb94-2"><a href="#cb94-2"></a></span>
<span id="cb94-3"><a href="#cb94-3"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">100</span>){</span>
<span id="cb94-4"><a href="#cb94-4"></a>matrizes[[i]] &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">100</span><span class="op">*</span><span class="dv">100</span>),<span class="dt">ncol =</span> <span class="dv">100</span>, <span class="dt">nrow =</span> <span class="dv">100</span>)</span>
<span id="cb94-5"><a href="#cb94-5"></a>}</span></code></pre></div>
<p>Veja o que o exemplo acima faz:</p>
<ul>
<li>Cria uma lista vazia chamada matrizes</li>
<li>Para cada posição da lista, ele vai criar uma matriz com 10 colunas e 100 linhas</li>
<li>o conteúdo dessa matriz são 1000 números saídos de uma normal de média zero e variância 1.</li>
</ul>
<p>Não foi especificado que a matriz tem que ser invertível: em nenhum ponto nós testamos isso. Nós poderíamos construir um teste usando <em>if</em>, de forma que se a matriz não for invertível (por exemplo, tem determinante zero), a matriz é ignorada. Mas observe que isso gera um problema: se a matriz for ignorada, o for continua e vai gerar uma matriz a menos do que queríamos. É ai que o <em>while</em> entra: podemos escrever o código com while de maneira que, quando a matriz tiver determinante 0, o contador não cresce. O código seria algo como:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1"></a> matrizes &lt;-<span class="st"> </span><span class="kw">list</span>()</span>
<span id="cb95-2"><a href="#cb95-2"></a> </span>
<span id="cb95-3"><a href="#cb95-3"></a> i &lt;-<span class="st"> </span><span class="dv">1</span></span>
<span id="cb95-4"><a href="#cb95-4"></a> <span class="cf">while</span>(i <span class="op">&lt;=</span><span class="st"> </span><span class="dv">100</span>){</span>
<span id="cb95-5"><a href="#cb95-5"></a> candidato &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">100</span><span class="op">*</span><span class="dv">100</span>),<span class="dt">ncol =</span> <span class="dv">100</span>, <span class="dt">nrow =</span> <span class="dv">100</span>)</span>
<span id="cb95-6"><a href="#cb95-6"></a> teste &lt;-<span class="st"> </span><span class="kw">det</span>(candidato)</span>
<span id="cb95-7"><a href="#cb95-7"></a> <span class="cf">if</span>(teste <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){} <span class="cf">else</span>{</span>
<span id="cb95-8"><a href="#cb95-8"></a> matrizes[[i]] &lt;-<span class="st"> </span>candidato</span>
<span id="cb95-9"><a href="#cb95-9"></a> i &lt;-<span class="st"> </span>i <span class="op">+</span><span class="st"> </span><span class="dv">1</span>}</span>
<span id="cb95-10"><a href="#cb95-10"></a> }</span></code></pre></div>
<p>Veja que só aumentamos o contador quando o determinante é diferente de zero , ou seja, quando aceitamos a matriz.</p>

<p>#Funções</p>
<p>Nesse capítulo explicamos o que são as funções, como e porque usar. Também damos algumas dicas de como criar as funções.</p>
<p>A primeira coisa que deve ser observada é que funções não se limitam a funções matemáticas: uma função recebe alguns inputs, faz algumas operações e devolve um output. Isso pode ser tão geral quanto necessário: de funções que recebem um valor de <span class="math inline">\(x\)</span> e retornam <span class="math inline">\(x^2+x+4\)</span> até funções que recebem matrizes e fazem operações complicadíssimas. Por exemplo, o comando <code>lm</code>, que usamos para estimar uma regressão linear, é uma função que recebe a variável dependente e a variável independente e faz uma série de operações com elas e devolve os coeficientes e seus erros padrões.</p>
<p>Em geral, funções são criadas para tarefas que serão repetidas várias vezes. Não faz nenhum sentido escrever uma função que só será usada uma única vez.</p>
<p>##Um exemplo simples: uma função matemática</p>
<p>Suponha que queremos uma função <span class="math inline">\(x^2+2x+4\)</span>, que iremos chamar de funcao. Nesse caso:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1"></a>funcao &lt;-<span class="st"> </span><span class="cf">function</span>(x){x<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">2</span><span class="op">*</span>x<span class="op">+</span><span class="dv">4</span>}</span></code></pre></div>
<p>Veja que, depois de function, entre parêntese, temos o nome da variável. Entre chaves o que a função de fato faz. Podemos criar uma função $ G = x^2 + y^2$. Nesse caso, o código é:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1"></a>G &lt;-<span class="st"> </span><span class="cf">function</span>(x,y){x<span class="op">^</span><span class="dv">2</span><span class="op">+</span>y<span class="op">^</span><span class="dv">2</span>}</span></code></pre></div>
<p>Veja que podemos precisar de definir funções como essas quando queremos integrar ou derivar usando o R. Mas em geral, um exemplo mais interessante de como (e porque) usar funções são exemplos não numéricos.</p>
<p>##Caso geral e exemplos</p>
<p>Em geral, funções são feitas da seguinte forma:</p>
<pre><code>nome_da_funcao &lt;- function(variaveis){
comandos
}</code></pre>
<p>Veja que podemos ter muitas variáveis - e em geral as funções do R tem dezenas de variáveis. Os comandos podem ser absolutamente qualquer coisa que o R faz: de rodar uma regressão até operações com arquivos. O importante ao escrever funções - e provavelmente o mais difícil - é estruturar as coisas de maneira geral: os inputs são as variáveis da função e não coisas que estão neste momento no ambiente do R.</p>
<p>Existem duas coisas importantes sobre funções que devem ser explicitadas antes de seguirmos para o próximo exemplo:</p>
<ol start="3" class="example" style="list-style-type: decimal">
<li>Variáveis podem ter defaults quando a função é construída. Por exemplo, na função <span class="math inline">\(G(x,y) = x^2+y^2\)</span>, podia ser o caso de que, exceto se o usuários especificasse ao contrário, o padrão fosse <span class="math inline">\(y = 0\)</span>. Para estabelecer essa mudança, bastaria alterar o código para:</li>
</ol>
<div class="sourceCode" id="cb99"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb99-1"><a href="#cb99-1"></a>G &lt;-<span class="st"> </span><span class="cf">function</span>(x,<span class="dt">y=</span><span class="dv">0</span>){x<span class="op">^</span><span class="dv">2</span><span class="op">+</span>y<span class="op">^</span><span class="dv">2</span>}</span></code></pre></div>
<p>Assim:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1"></a><span class="kw">G</span>(<span class="dv">1</span>)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb102"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1"></a><span class="kw">G</span>(<span class="dv">1</span>,<span class="dv">0</span>)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<ol start="4" class="example" style="list-style-type: decimal">
<li>Os exemplos de funções matemáticas foram muito simples e o R sabe exatamente qual resultado deve ser exibido. Isso nem sempre é verdade, e em funções mais complicadas usamos o comando <code>return</code>. O comando só funciona dentro de funções e diz o que a função deve retornar como resposta. No exemplo da função numérica, poderíamos ter escrito:</li>
</ol>
<pre><code>g &lt;- function(x,y){return(x^2+y^2)}</code></pre>
<p>Vamos aplicar essas duas ideias. Suponha que queremos gerar duas amostras de normais independentes que podem ter médias e variâncias diferentes. Também queremos poder mudar o tamanho da amostra. No fim, essa função deve retornar uma matriz <span class="math inline">\(n \times 2\)</span>, onde n é o tamanho da amostra. E ainda queremos que, por padrão, as duas variáveis sejam uma normal padrão (com média zero e variância 1). Podemos escrever:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1"></a>amostrador &lt;-<span class="st"> </span><span class="cf">function</span>(n,<span class="dt">media_x =</span> <span class="dv">0</span>,<span class="dt">media_y =</span> <span class="dv">0</span>,<span class="dt">variancia_x =</span> <span class="dv">1</span>,<span class="dt">variancia_y =</span> <span class="dv">1</span>){</span>
<span id="cb105-2"><a href="#cb105-2"></a>sd_x &lt;-<span class="st"> </span><span class="kw">sqrt</span>(variancia_x)</span>
<span id="cb105-3"><a href="#cb105-3"></a>sd_y &lt;-<span class="st"> </span><span class="kw">sqrt</span>(variancia_y)</span>
<span id="cb105-4"><a href="#cb105-4"></a>amostra.x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n,media_x,sd_x)</span>
<span id="cb105-5"><a href="#cb105-5"></a>amostra.y &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n,media_y,sd_y)</span>
<span id="cb105-6"><a href="#cb105-6"></a><span class="kw">return</span>(<span class="kw">cbind</span>(amostra.x,amostra.y))</span>
<span id="cb105-7"><a href="#cb105-7"></a>}</span>
<span id="cb105-8"><a href="#cb105-8"></a><span class="kw">amostrador</span>(<span class="dv">100</span>)</span></code></pre></div>
<pre><code>##           amostra.x     amostra.y
##   [1,]  0.718293633  0.8600844047
##   [2,]  0.335490839 -0.6635724390
##   [3,]  0.075343566 -0.0347763790
##   [4,] -0.176943345 -0.6273394950
##   [5,] -1.399367025  0.0685600449
##   [6,]  0.824329709  2.3781543355
##   [7,] -0.825091214 -2.1556493943
##   [8,]  1.127722302 -1.1029162042
##   [9,] -0.554740916 -0.4661599986
##  [10,] -1.244439780 -1.0006704603
##  [11,] -0.138147415  0.5064026291
##  [12,]  1.479458744 -0.5979431848
##  [13,] -0.399006457 -0.5678099122
##  [14,] -0.298111446  0.5977321127
##  [15,] -0.460745195 -1.0826113473
##  [16,]  0.213153398 -0.8901032945
##  [17,]  0.421186752  0.1060644426
##  [18,]  0.123760415 -1.2325415929
##  [19,] -0.414138818  0.1624707549
##  [20,] -0.005033633 -0.0092806873
##  [21,] -0.897773702  1.2750918238
##  [22,] -0.447641572  0.7263910524
##  [23,] -0.789351119  0.8028114959
##  [24,]  0.840028977 -1.0008340604
##  [25,]  0.333345310  0.8115257895
##  [26,]  1.155416496  1.0275551784
##  [27,] -1.558740363  0.2122541549
##  [28,]  0.402093862  0.3342644371
##  [29,] -0.199965083  1.3114180333
##  [30,]  0.611341071 -1.4002469437
##  [31,] -0.199792406 -1.3343064007
##  [32,] -1.240993238  0.3327949851
##  [33,] -0.260099772 -2.0509916193
##  [34,]  0.502905052  0.2436862171
##  [35,]  0.513583267  0.8256682003
##  [36,]  0.002368356  1.1068085957
##  [37,]  0.081781460  0.9155825468
##  [38,]  0.893233840  2.0988221508
##  [39,] -0.299933476 -0.3790194478
##  [40,]  1.584847797  1.7640485807
##  [41,] -0.323163550  0.4117237831
##  [42,]  0.387489985 -0.7852152744
##  [43,]  0.593746646 -0.0253192137
##  [44,] -1.143210475 -1.4664721334
##  [45,] -0.699134922  0.8255766770
##  [46,] -0.563157663 -0.3015198950
##  [47,] -0.361755194  0.1428712879
##  [48,] -0.653561737  0.1107993982
##  [49,] -1.401316927 -1.1725290692
##  [50,]  0.060215438  0.1113076746
##  [51,]  0.269842008  0.1253386577
##  [52,]  1.082226553  0.6139166447
##  [53,]  1.739625645  0.6517269830
##  [54,] -1.195713070  1.8574078587
##  [55,]  0.017556296 -0.2771270834
##  [56,]  0.348467439 -1.1719939039
##  [57,] -0.442743053 -0.6028888749
##  [58,]  3.514987716 -1.9474615939
##  [59,]  0.268012018  0.0804247766
##  [60,] -0.533351024  1.0777988315
##  [61,]  0.100036351 -1.2256136083
##  [62,]  0.566710062  0.6093026921
##  [63,]  1.244379105  0.2619515119
##  [64,] -0.486077795 -2.1120820058
##  [65,] -0.882803939 -1.4624106153
##  [66,] -0.044538809  1.0629601542
##  [67,]  0.217141987 -0.9362078957
##  [68,]  0.082830345 -0.0009904007
##  [69,]  0.569970979  1.3052634445
##  [70,]  1.132305312  0.3289079820
##  [71,] -1.002768739 -0.3067718459
##  [72,]  1.787110564  1.6125236822
##  [73,]  0.114321186 -0.1428698182
##  [74,] -0.339733905  0.3457300380
##  [75,]  1.405884945  0.4963447043
##  [76,]  0.862362952  0.6118068059
##  [77,]  0.289956879 -0.7188252473
##  [78,]  0.372402586 -0.5769010422
##  [79,]  1.379126387  1.2464906871
##  [80,]  0.480186944  2.4390593987
##  [81,] -1.135746773 -0.1380849325
##  [82,]  0.866156568 -1.2708188670
##  [83,] -0.253460661  0.7887372997
##  [84,]  1.458718311 -0.3444853735
##  [85,] -1.218927165  0.2389165249
##  [86,]  1.075248398  1.5627028348
##  [87,] -1.441709195  1.7651224708
##  [88,] -1.063758528  0.2834147918
##  [89,] -1.168627898 -0.9832919370
##  [90,]  2.581455827 -0.6917566099
##  [91,] -0.162559882 -0.4689404239
##  [92,]  1.752839346  0.7502401100
##  [93,]  0.279718930  0.0669117622
##  [94,]  0.893623404 -0.3089511493
##  [95,]  0.647039934 -0.4952645078
##  [96,]  0.114351976 -1.7746561672
##  [97,]  0.574657439  0.4421593193
##  [98,]  1.469561653 -2.0933514087
##  [99,] -1.348346843 -0.0415687559
## [100,] -0.426303663  0.7376097284</code></pre>
<p>Veja que, como o <code>rnorm</code> recebe o desvio padrão da distribuição e a minha função tem como parâmetro a variância da distribuição, criei uma variável na função que tira a raiz quadrada.</p>
<p><strong>Atenção: checando argumentos</strong>
É importante notar que em todos os casos, os argumentos de uma função são restritos de alguma forma: no exemplo acima, <span class="math inline">\(n\)</span> tem que ser um número inteiro; a variância não pode ser negativa. Aqui, isso não é tão importante por dois motivos: (1) eu estou assumindo que só você vai usar a função e você sabe o que cada argumento recebe, (2) o <code>rnorm</code> daria um erro caso você violasse essas duas restrições. Isso nem sempre é verdade e pode gerar muitos problemas, então em geral desenvolvedores sérios criam ifs que checam o tipo do argumento passado. Isso vai além do escopo do manual.</p>
<p>##Por que escrever funções?</p>
<p>Escrever funções nem sempre é fácil, especialmente para iniciantes. Uma função te força a escrever tudo em termos gerais: um n que não existe, um vetor que ainda não foi criado, etc. Como dito no inicio deste capítulo, funções são criadas para tarefas que serão repetidas várias vezes. Em geral, há uma tentação de copiar e colar o código várias vezes fazendo as alterações necessárias ``no braço’’.</p>
<p>Não caia nesta tentação! Há dois motivos básicos para isso:</p>
<ul>
<li>O seu código vai ser ilegível em pouco tempo, com milhares de linhas repetidas que você é incapaz de ver qual a diferença</li>
<li>É muito fácil esquecer de mudar uma parte do código e a coisa dar erro, ou ainda pior, rodar e te dar um resultado errado.</li>
</ul>
<p>Este autor já precisou rodar de novo várias partes de código que demoravam horas por esquecer de mudar alguma pequena coisa no código copiado e colado. Usar funções é uma maneira muito mais razoável de resolver o problema e, uma vez criada e debbugada, a dor de cabeça é muito menor. Quando o autor aprendeu R, ele foi informado de que escrever tudo em funções era o ideal e ignorou. Esta parece ser uma das muitas coisas que só se aprende cometendo o erro.</p>
<p>##Como escrever funções</p>
<p>Um dos principais motivos para iniciantes no R ignorarem a sugestão da seção anterior é que escrever funções pode ser desafiador. Escrever a função exige, de antemão, que você saiba o tamanho dos vetores, matrizes, como o código irá se comportar etc. Existe uma maneira simples de mitigar este desafio: comece escrevendo o caso específico e depois generalize. No exemplo das duas amostras normais, nós poderiamos ter começado escrevendo apenas:</p>
<pre><code>amostra.x &lt;- rnorm(100,0,1)
amostra.y &lt;- rnorm(100,2,2)</code></pre>
<p>E depois ter generalizado: sabemos que 100 é o tamanho da amostra, então troque por n. Para permitir médias diferentes (como o código acima fez), colocamos duas variáveis no lugar - com nomes que evidenciam o que elas fazem. Etc. No fim, só precisamos colocar, no começo, o <code>nome.da.funcao &lt;- function(argumentos){</code>e fechar com o <code>return</code> de maneira a amarrar as duas amostras (cbind, talvez).</p>
<p>Outro desafio é que o <code>return</code> só aceita um único objeto, ou seja, funções no R só retornam uma única coisa. Em alguns casos isso é um desafio. Voltando ao exemplo das duas amostras, <code>return(amostra.x,amostra.y)</code> daria um erro. A solução aqui é simples: cole os dois vetores em uma matriz. Mas nem sempre isso é possível: e se os vetores tiverem dimensão diferente? E se a função gera várias matrizes?</p>
<p>Nesses casos, lembre que <code>list()</code> recebe qualquer coisa. Você pode ter um elemento na lista que é só um número, outro que é um vetor e até uma lista! O comando <code>lm</code> retorna, de fato, uma lista. Dentro da lista há um vetor com os coeficientes, uma matriz de variância covariância e outras coisas.</p>
<p>Uma terceira dica é quebrar uma função grande em funções menores. O R permite que uma função chame outra, o que facilita em muito o processo de criação de funções complicadas. Em um exemplo extremo, poderíamos imaginar que você quer fazer uma função que faz OLS para você. Poderiamos quebrar isso em vários pedaços: uma que estima os coeficientes, outra que calcula o erro padrão, uma terceira que faz a conta do <span class="math inline">\(R^2\)</span>…e finalmente uma última que amarra todas essas funções e devolve uma lista com os coeficientes, erros padrões e tudo mais.</p>

<p>#Paralelizando</p>
<p>Muitas tarefas no R consomem muito tempo. <em>Loops</em> longos são um caso particular disso. Se cada iteração do loop demora 1s e você pede para repetir a iteração mil vezes, você gasta mil segundos (16 minutos)! Infelizmente, muitas operações acabam caindo em problemas que são <em>loops</em>. Felizmente, existe uma maneira de agilizar o processo.</p>
<p>Isso se deve a dois fatos. O primeiro é que a estrutura do <em>for</em> muitas vezes permite que cada tarefa seja feita separadamente. Isso é muito frequente em simulações, que serão tratadas em mais detalhes mais a frente. O outro fato é que o R não aproveita 100% da capacidade da maioria dos computadores atuais. Os computadores atuais vem com processadores com mais de um núcleo (<em>multi core</em><a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a>). Cada núcleo age como um pequeno processador e o computador distribui as tarefas entre estes núcleos.</p>
<p>Em um <em>for</em>, poderíamos dar cada iteração do loop para núcleo do processador, e quando o núcleo termina a iteração ele devolve a resposta recebe uma nova iteração para fazer. Isso é chamado de paralelização e agiliza muito situações em que precisamos de um <em>loop</em>.</p>
<p>Podemos pensar em uma situação equivalente bastante prática: suponha que queremos multiplicar todos os números de 1 a 10. Se sentarmos uma única pessoa para fazer a conta, esta pessoa vai demorar. Entretanto, se tivermos quatro pessoas na sala, podemos deixar a primeira pessoa multiplicar 1,2,3; a segunda 3,4,5; a terceira 6,7,8; e a quarta 9,10. No fim, pegamos o resultado e pedimos para a primeira e a quarta pessoa multiplicarem seus resultados com os resultados da segunda e da terceira, respectivamente. E por último multiplicamos o resultado que elas obtiveram. De fato, antes da existência dos computadores, contas complicadas eram feitas assim!</p>
<p>O tratamento dessa seção deve muito a este <a href="http://michaeljkoontz.weebly.com/uploads/1/9/9/4/19940979/parallel.pdf">documento</a></p>
<p>##Desafios computacionais de paralelização</p>
<p>A primeira coisa a se observar é que paralelizar coloca um enorme peso sobre o computador. O R gera novos processos e cada um vai para um núcleo do processador. Isso deixa o computador sobre uma carga brutal de trabalho. Assim, rodar código paralelizado usualmente requer que você deixe o computador fazendo apenas o que você pediu para o R e nada mais.</p>
<p>Outro problema é que processos paralelizados gastam muita memória RAM. Assim, é importante ficar de olho no consumo de RAM (via gerenciador de tarefas). Tratarei desse problema mais a frente, mas uma boa regra de bolso é que cada núcleo precisa de mais ou menos um 1,5GB de RAM. Mas isso vai variar de sistema para sistema.</p>
<p>##Configurando o R para paralelizar</p>
<p>Vamos precisar de dois pacotes para a paralelização: o <strong>foreach</strong> e o <strong>doParallel</strong>. Carregue os dois pacotes. É sempre bom saber quantos núcleos nós temos, e isso é possível via o comando <code>detectcores()</code>. Na sequência só precisamos definir o número de núcleos, que no código a seguir foi definido pela variável <code>n.cores</code>. O resto dos comandos é padrão e não temos que entender o que cada um faz:</p>
<pre><code>n.cores &lt;- 3
cl &lt;- makeCluster(n.cores)
registerDoParallel(cl)</code></pre>
<p>Observe que até podemos definir um número de núcleos maior do que o que <code>detectcores()</code> mostra, mas isso vai ser extremamente problemático: nós teremos 30 seções do R disputando por recursos do computador. Como regra de bolso, <code>n.cores</code> deve ser, no máximo, como o número de núcleos que o <code>detectcores()</code> encontrou menos 1.</p>
<p>Para checar se o R registrou corretamente e consegue usar os processos paralelizados, use o comando <code>getDoParWorkers()</code>. Ele irá indicar o mesmo número que você colocou no <code>n.cores</code> se tudo tiver dado certo.</p>
<p>##Usando a paralelização</p>
<p>Uma vez configurado, temos mais uma etapa: o comando <code>for</code> usual do R não consegue usar as vantagens da paralelização. Por isso, precisamos usar o comando <code>foreach</code>, que é muito semelhante, mas tem diferenças importantíssimas. A primeira é que o <code>foreach</code> vai gerar um objeto, ao contrário do for. Você pode explicar qual o objeto vai ser gerado usando a opção .combine entre as opções. O default é criar uma lista. Também é importante entender que o que vai ser colocado no objeto que o R vai gerar com o <code>foreach</code> é o último comando dentro do foreach <strong>que não é a criação de um objeto</strong>.</p>
<p>A sintaxe do foreach também é diferente: não usamos o in do for e precisamos colocar um <code>%dopar%</code> entre o parênteses e as chaves. Assim, para repetir alguma coisa n vezes:</p>
<pre><code>objeto &lt;- foreach(i=1:n) %dopar% {

comandos

}</code></pre>
<p>Um exemplo deve clarificar. Suponha que queremos tirar a raiz quadrada de todos os números de 1 a 20 e queremos paralelizar isso. Escreveríamos o código da seguinte maneira:</p>
<pre><code>raizes &lt;- foreach(i = 1:20) %dopar%  {

sqrt(i)

}</code></pre>
<p>Veja que o R vai devolver uma lista. Se quissemos que ele devolvesse um vetor (que parece mais razoável no caso), teriamos que ter alterado o parêntese para (i = 1:20, .combine = c). Veja que se tivéssemos usado <code>a &lt;- sqrt(i)</code>, ao invés de <code>sqrt(i)</code>, o R teria devolvido uma lista vazia.</p>
<p>[^1:]Dai dual core, quad core etc.</p>

<p>#Otimização</p>
<p>Muitas vezes precisamos resolver problemas que são problemas de maximização ou minimização. Por exemplo, o problema de uma regressão por MQO pode ser escrito como minimizar a soma do quadrado dos erros. O problema de máxima verossimelhança envolve escolher paramêtros que maximizam uma função de densidade conjunta. Esse capítulo explica algumas ideias básicas de como fazer otimização no R.</p>
<p>Antes de começarmos, é necessário um aviso importante: otimização no computador raramente é feita tirando a primeira derivada e igualando a zero. Existe uma variedade de algoritmos que fazem otimização e o tema é excessivamente amplo para ser coberto com calma. O <em>Numerical Methods in Economics</em>, de Kenneth Judd, trata de alguns desses métodos - mas saiba que o tema não é simples. Esse capítulo foi escrito de maneira que você pode pular a seção <em>Mais sobre otimização númerica</em>. Mas eu recomendo fortemente a leitura.</p>
<p>##Optimize e Optim</p>
<p>O R vem, por padrão, com duas funções básicas para otimização: o <code>optimize</code> e o <code>optim</code>. A diferença entre eles é que o primeiro é para quando se tem uma variável para ser otimizada, e o segundo para mais de uma variável. Em ambos os casos, entretanto, temos que escrever uma função antes, então começaremos por ai. Vamos trablhar com duas funções para entender como usar os comandos: <span class="math inline">\(f(x)=x^2\)</span> e <span class="math inline">\(g(x,y)=x^2+y^2\)</span>. Veja que sabemos que o mínimo em ambas é colocar todos os argumentos igual a zero. Já aprendemos a escrever funções. <strong>Uma idiosincrasia importante para o caso de mais de uma variável</strong> é que precisamos ter apenas um argumento para as variáveis a serem otimizadas, que deve ter a forma de um vetor. Assim, se tivermos dois argumentos na função matemática, teremos um argumento na função do R que vai ser um vetor com duas posições. Escrevemos as funções <span class="math inline">\(f(x)\)</span> e <span class="math inline">\(g(x,y)\)</span>:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1"></a>f &lt;-<span class="st"> </span><span class="cf">function</span>(x){x<span class="op">^</span><span class="dv">2</span>}</span>
<span id="cb111-2"><a href="#cb111-2"></a>g &lt;-<span class="st"> </span><span class="cf">function</span>(x) {x[<span class="dv">1</span>]<span class="op">^</span><span class="dv">2</span><span class="op">+</span>x[<span class="dv">2</span>]<span class="op">^</span><span class="dv">2</span>}</span></code></pre></div>
<p>Vamos começar com o <code>optimize</code>: o primeiro argumento é a função e o segundo é o intervalo da busca. Sabemos que o mínimo é igual a zero, então vamos colocar o intervalo entre -2 e 2:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb112-1"><a href="#cb112-1"></a><span class="kw">optimize</span>(f,<span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>))</span></code></pre></div>
<pre><code>## $minimum
## [1] -5.551115e-17
## 
## $objective
## [1] 3.081488e-33</code></pre>
<p>Observe que, apesar de normalmente usarmos a função no R como <code>f(x)</code>, o comando recebe apenas <code>f</code>. A resposta tem dois componentes: o valor da variável que minimiza a função (<code>$minimum</code>) e o valor da função nesse ponto ( <code>$objective</code>). Veja que o R não nos devolveu 0 como o valor que minimiza: a minimização é numérica e vai ser sempre um valor aproximado. Mas <span class="math inline">\(-5.55 10^{-17}\)</span> é, para todos os efeitos, zero.</p>
<p>Vamos trabalhar agora com a nossa função com duas variáveis. Usamos o comando optimize que recebe primeiro um chute inicial e depois a função. O chute incial deve ser um vetor. Sabemos que o ótimo é o vetor <span class="math inline">\((0,0)\)</span>, então para dar algum trabalho para o computador vamos chutar <span class="math inline">\((-1,1)\)</span>:</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1"></a><span class="kw">optim</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>),g)</span></code></pre></div>
<pre><code>## $par
## [1]  0.0001134426 -0.0001503306
## 
## $value
## [1] 3.546849e-08
## 
## $counts
## function gradient 
##       55       NA 
## 
## $convergence
## [1] 0
## 
## $message
## NULL</code></pre>
<p>Veja que a resposta nos trás os valores que minimizam( <code>$par</code>), o valor da função nesse ponto( <code>$value</code>) e algumas outras informações: a mais importante é o <code>$convergence</code>, que nos diz se o algoritmo convergiu ou não - isso é, se encontramos um ótimo ou não. Em geral, se temos um 0 é que tudo ocorreu bem. Outros valores indicam erro e cada algoritmo dá um significado para cada valor.</p>
<p>###Mais sobre Otimização Numérica</p>
<p>Infelizmente, o chute inicial pode ser muito importante em alguns casos. Pegue a função <span class="math inline">\(h(x,y)=x^3+y^2+x*y\)</span>. Vamos testar dois chutes inciais: <span class="math inline">\((0,0)\)</span> e <span class="math inline">\((-10,0)\)</span>:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb116-1"><a href="#cb116-1"></a>h &lt;-<span class="st"> </span><span class="cf">function</span>(x){x[<span class="dv">1</span>]<span class="op">^</span><span class="dv">3</span><span class="op">+</span>x[<span class="dv">2</span>]<span class="op">^</span><span class="dv">2</span><span class="op">+</span>x[<span class="dv">1</span>]<span class="op">*</span>x[<span class="dv">2</span>]}</span>
<span id="cb116-2"><a href="#cb116-2"></a></span>
<span id="cb116-3"><a href="#cb116-3"></a><span class="kw">optim</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>),h)</span></code></pre></div>
<pre><code>## $par
## [1]  0.16666670 -0.08333335
## 
## $value
## [1] -0.002314815
## 
## $counts
## function gradient 
##       99       NA 
## 
## $convergence
## [1] 0
## 
## $message
## NULL</code></pre>
<div class="sourceCode" id="cb118"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb118-1"><a href="#cb118-1"></a><span class="kw">optim</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">10</span>,<span class="dv">0</span>),h)  </span></code></pre></div>
<pre><code>## $par
## [1] -3.183805e+56  2.684172e+56
## 
## $value
## [1] -3.2273e+169
## 
## $counts
## function gradient 
##      501       NA 
## 
## $convergence
## [1] 1
## 
## $message
## NULL</code></pre>
<p>Veja que, no primeiro caso, temos convergência; no segundo, a coisa dá totalmente errada e não há convergência (por isso o código 1 ali no <code>$convergence</code>).</p>
<p>Veja que pode ser o caso de que queremos encontrar o máximo de uma função. O optimize tem uma opção <code>maximum</code>, e basta alterar para <code>TRUE</code>. Entretanto, o <code>optim</code> não tem essa opção. A solução é simples: multiplique a função por <span class="math inline">\(-1\)</span>. Por exemplo, o máximo de <span class="math inline">\(j(x)=- x^2\)</span> é o mesmo ponto que o mínimo de <span class="math inline">\(f(x)=x^2\)</span>. A única coisa que vai mudar é o valor da função no ponto.</p>
<table>
<tr>
<th bgcolor="#adadeb">
Hands on!
</th>
</tr>
<tr>
<td bgcolor="#adadeb">
O estimador de Mínimos Quadrados Ordinário pode ser escrito como um problema de minimização (quem poderia imaginar?!). O objetivo é minimizar a soma do quadrado do erro. Veja que podemos então gerar duas amostras (<span class="math inline">\(x\)</span> e <span class="math inline">\(e\)</span>) e definir $ y = x + e$. Para estimar o modelo, bastaria criar uma função que calcula a soma do erro do quadrado dado os parametros, ou seja, para valores <code>b[1] e b[2]</code>, a função faz <code>y - b[1] + b[2]*x</code> e soma o quadrado desses valores. Jogue essa função no <code>optim</code>e provavelmente você obterá bons resultados.
</td>
</tr>
</table>
<p>##Otimizando com restrição</p>
<p>Por enquanto só tratamos de otimização irrestrita. Mas podemos querer otimizar também com restrição. A melhor opção nesse caso é o pacote <em>CVXR</em>. A sintaxe é bastante diferente da sintaxe usual. O problema é constrúido em blocos, e o tratamento dessa seção se deve a <a href="https://cran.r-project.org/web/packages/CVXR/vignettes/cvxr_intro.html">este documento</a> do pacote:</p>
<ul>
<li>A variável de escolha é criada com o <code>Variable</code></li>
<li>A função objetivo não é escrita usando o <code>function</code>, mas sim criado uma variável com <code>Minimize("expressão")</code> ou <code>Maximize("expressão")</code>. O uso de cada um deve ser auto-explicativo.</li>
<li>Crie variáveis com as restrições sobre a variável criada com o variable</li>
<li>Crie mais uma variável usando <code>Problem</code>, que recebe a função objetivo e as restrições em uma lista(mesmo se for apenas uma restrição</li>
<li>Passe a variável acima para a função <code>solve</code></li>
</ul>
<p>O link acima conta com um exemplo de como fazer MQO usando o CVXR. No capítulo Projetinhos, eu explico como fazer o LASSO (Least Abssolute Shrinkage and Selection Operator) usando o CVXR.</p>

<p>#Projetinhos</p>
<p>Esse capítulo traz uma série de ideias para serem implementadas no R. Todos os exemplos são da estatística, por enquanto. Propositalmente, o código que resolve o problema está no fim de cada seção. Tente fazer sem olhar. Veja que as soluções propostas não miram o máximo de eficiência possível, mas sim serem o mais claras possíveis. E, como quase tudo na vida, existe mais de uma solução.</p>
<p>##Lei dos Grandes Números</p>
<table>
<tr>
<td>
Dificuldade
</td>
<td>
Fácil
</td>
</tr>
<tr>
<td>
Capítulos necessários
</td>
<td>
5
</td>
</tr>
</table>
<p>Vamos relembrar o que diz a lei dos grandes números. Em linhas gerais, se <span class="math inline">\(x\)</span> é uma variável aletória com expectância <span class="math inline">\(\mu\)</span>, e <span class="math inline">\(\bar{X} = \frac{1}{n}\sum_i x_i\)</span>, a média amostral, então <span class="math inline">\(\text{plim}_{n \rightarrow \infty}(\bar{X}) = \mu\)</span> . É isso que justifica, por exemplo, usar estimadores do método dos momentos: se você tem algum momento da distribuição que tem que ser estimado, então o equivalente amostral dele converge para o valor verdadeiro. Vamos colocar isso a prova. Eis aqui um passo a passo do que queremos fazer:</p>
<ul>
<li>Gere um vetor de variáveis aleatórias retirados de alguma distribuição, com algum tamanho de amostra (por exemplo, <code>rnorm(1000)</code>). Vamos chamar esse vetor de <code>amostra</code>.</li>
<li>Crie um vetor de zeros (você pode fazer isso usando <code>rep(0,1000)</code>, que vai gerar um vetor de mil zeros) Chame ele de alguma coisa. No caso, chamarei ele de <code>media</code></li>
<li>Crie um loop que faz com que cada posição do vetor <code>media</code> seja a média dos números em <code>amostra</code> até aquela posição. Assim, se tivermos na 4ª posição de <code>media</code>, teremos a média dos números da <code>amostra</code> de 1 a 4.</li>
<li>Faça o plot desses pontos para saber se há convergência de fato</li>
</ul>
<div class="sourceCode" id="cb120"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb120-1"><a href="#cb120-1"></a>amostra &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1000</span>)</span>
<span id="cb120-2"><a href="#cb120-2"></a>media &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">1000</span>)</span>
<span id="cb120-3"><a href="#cb120-3"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">1000</span>){</span>
<span id="cb120-4"><a href="#cb120-4"></a>  media[i] &lt;-<span class="st"> </span><span class="kw">mean</span>(amostra[<span class="dv">1</span><span class="op">:</span>i])</span>
<span id="cb120-5"><a href="#cb120-5"></a>}</span>
<span id="cb120-6"><a href="#cb120-6"></a><span class="kw">plot</span>(media)</span>
<span id="cb120-7"><a href="#cb120-7"></a><span class="kw">lines</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">1000</span>,<span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">1000</span>), <span class="dt">col =</span> <span class="dv">2</span>, <span class="dt">lwd =</span> <span class="dv">2</span>) <span class="co">#linha vermelha no valor verdadeiro do parâmetro</span></span></code></pre></div>
<p><img src="Bookdown_files/figure-html/unnamed-chunk-38-1.png" width="672" /></p>
<p>Esse é um exemplo básico, mas a ideia é mais poderosa: e se tivermos um momento da forma <span class="math inline">\(E(xu)=0\)</span>, onde x e u são variáveis aleatórias univariadas?<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a> Se a lei dos grandes números é verdadeira, <span class="math inline">\(\widehat{E(xu)} = \sum_i x_i u_i\)</span> deve convergir para zero. Vamos testar seguindo a mesma ideia acima. A única diferença é que a nossa média vai ter que ser calculada sem a função padrão <code>mean</code>:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb121-1"><a href="#cb121-1"></a>amostra<span class="fl">.1</span> &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1000</span>)</span>
<span id="cb121-2"><a href="#cb121-2"></a>amostra<span class="fl">.2</span> &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1000</span>)</span>
<span id="cb121-3"><a href="#cb121-3"></a></span>
<span id="cb121-4"><a href="#cb121-4"></a>prod &lt;-<span class="st"> </span>amostra<span class="fl">.1</span><span class="op">*</span>amostra<span class="fl">.2</span></span>
<span id="cb121-5"><a href="#cb121-5"></a></span>
<span id="cb121-6"><a href="#cb121-6"></a>momento &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">1000</span>)</span>
<span id="cb121-7"><a href="#cb121-7"></a></span>
<span id="cb121-8"><a href="#cb121-8"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">1000</span>){</span>
<span id="cb121-9"><a href="#cb121-9"></a>  momento[i] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span>i<span class="op">*</span><span class="kw">sum</span>(prod[<span class="dv">1</span><span class="op">:</span>i])</span>
<span id="cb121-10"><a href="#cb121-10"></a>}</span>
<span id="cb121-11"><a href="#cb121-11"></a></span>
<span id="cb121-12"><a href="#cb121-12"></a><span class="kw">plot</span>(momento)</span>
<span id="cb121-13"><a href="#cb121-13"></a><span class="kw">lines</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">1000</span>,<span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">1000</span>), <span class="dt">col=</span> <span class="dv">2</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)</span></code></pre></div>
<p><img src="Bookdown_files/figure-html/unnamed-chunk-39-1.png" width="672" /></p>
<p>##Mínimos Quadrados Ordinários</p>
<table>
<tr>
<td>
Dificuldade
</td>
<td>
Intermediário
</td>
</tr>
<tr>
<td>
Capítulos necessários
</td>
<td>
1, 6, 5 (Só a seção de if)
</td>
</tr>
<tr>
Eu uso matrizes extensivamente nesse exemplo!
</tr>
</table>
<p>O estimador de MQO é o estimador mais fundamental da econometria. Existe mais de uma maneira de derivar ele: podemos ver como um problema de minimização, como fizemos no capítulo 8; aqui, vamos derivar ele a partir da condição de momento <span class="math inline">\(E(xu) = 0\)</span> para todo x, e onde <span class="math inline">\(u\)</span> representa o erro. Veja que se fizermos uma matriz <span class="math inline">\(X\)</span>, que tem em cada linha uma observação e em cada coluna uma variável, e <span class="math inline">\(\mathbf{u}\)</span> o vetor de erros <span class="math inline">\(n \times{} 1\)</span>, <span class="math inline">\(\mathbf{y}\)</span>, o vetor da variável dependente também <span class="math inline">\(n \times{} 1\)</span>, então a condição de momento se torna <span class="math inline">\(E(X^{&#39;}\mathbf{u})=0\)</span>. Se expandirmos isso, usando o fato que <span class="math inline">\(\mathbf{u} = \mathbf{y}-X\beta\)</span>. Então:</p>
<p><span class="math display">\[E(X^{&#39;}\mathbf{u})=E(X^{&#39;}(\mathbf{y}-X\beta))=E(X^{&#39;}\mathbf{y})-E(X^{&#39;}X)\beta = 0 \therefore E(X^{&#39;}\mathbf{y})=E(X^{&#39;}X)\beta \therefore \beta_{OLS} = E(X^{&#39;}X)^{-1}E(X^{&#39;}\mathbf{y})\]</span>
Vamos implementar ele no R. Vamos criar uma função que pega a matriz <span class="math inline">\(X\)</span> e o vetor y e faz a conta para obter o MQO. Precisamos de:</p>
<ul>
<li><code>%*%</code>, que multiplica duas matrizes, ou um vetor e uma matriz</li>
<li><code>solve</code>que inverte a matriz</li>
<li><code>t</code>que transpõe a matriz</li>
</ul>
<div class="sourceCode" id="cb122"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb122-1"><a href="#cb122-1"></a>mqo &lt;-<span class="st"> </span><span class="cf">function</span>(x,y){</span>
<span id="cb122-2"><a href="#cb122-2"></a>  bloco_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">t</span>(x)<span class="op">%*%</span>x</span>
<span id="cb122-3"><a href="#cb122-3"></a>  bloco_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">t</span>(x)<span class="op">%*%</span>y</span>
<span id="cb122-4"><a href="#cb122-4"></a>  <span class="kw">return</span>(<span class="kw">solve</span>(bloco_<span class="dv">1</span>)<span class="op">%*%</span>bloco_<span class="dv">2</span>)</span>
<span id="cb122-5"><a href="#cb122-5"></a>}</span></code></pre></div>
<p>Com uma meia dúzia de manipulações (trocando o <span class="math inline">\(y\)</span> do <span class="math inline">\(\beta_{OLS}\)</span> por <span class="math inline">\(u\)</span> e fazendo <span class="math inline">\(\beta \beta^{&#39;}\)</span>), obtemos a expressão para a variância do estimador de OLS:</p>
<p><span class="math display">\[Var(\beta_{OLS}) = (X^{&#39;}X)^{-1}X^{&#39;}DX(X^{&#39;}X)^{-1}\]</span></p>
<p>Onde <span class="math inline">\(D\)</span> é uma matriz diagonal cuja as entradas na diagonal são os elementos da diagonal de <span class="math inline">\(uu^{&#39;}\)</span><a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>. Então, para obtermos a variância do OLS, precisamos calcular primeiro o resíduo. Vamos criar duas funções: uma para calcular os resíduos, e outra que calcula a variância do <span class="math inline">\(\beta_{OLS}\)</span>. A função que calcula a variância vai chamar a função que calcula os resíduos. Veja que podemos fazer essas funções de várias maneiras: a função que calcula o resíduo pode recber só o X e y e chamar a função <code>mqo</code> para fazer a conta do coeficiente; ou a função pode receber X,y <em>e</em> o coeficiente para calcular o resíduo. Eu vou escolher o segundo caminho:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb123-1"><a href="#cb123-1"></a>residuo &lt;-<span class="st"> </span><span class="cf">function</span>(x,y,cofs){</span>
<span id="cb123-2"><a href="#cb123-2"></a>  u &lt;-<span class="st"> </span>y <span class="op">-</span><span class="st"> </span>x<span class="op">%*%</span>cofs</span>
<span id="cb123-3"><a href="#cb123-3"></a>  <span class="kw">return</span>(u)</span>
<span id="cb123-4"><a href="#cb123-4"></a>}</span>
<span id="cb123-5"><a href="#cb123-5"></a></span>
<span id="cb123-6"><a href="#cb123-6"></a>variancia_mqo &lt;-<span class="st"> </span><span class="cf">function</span>(x,y){</span>
<span id="cb123-7"><a href="#cb123-7"></a>  cof &lt;-<span class="st"> </span><span class="kw">mqo</span>(x,y)</span>
<span id="cb123-8"><a href="#cb123-8"></a>  res &lt;-<span class="st"> </span><span class="kw">residuo</span>(x,y,cof)</span>
<span id="cb123-9"><a href="#cb123-9"></a>  bloco_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">solve</span>(<span class="kw">t</span>(x)<span class="op">%*%</span>x)</span>
<span id="cb123-10"><a href="#cb123-10"></a>  D &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">ncol =</span> <span class="kw">nrow</span>(x),<span class="dt">nrow=</span><span class="kw">nrow</span>(x))</span>
<span id="cb123-11"><a href="#cb123-11"></a>  <span class="kw">diag</span>(D) &lt;-<span class="st"> </span><span class="kw">diag</span>(res<span class="op">%*%</span><span class="kw">t</span>(res)) <span class="co">#diag acessa os elmentos da diagonal da matriz: logo, eu estou contando para o R que os elementos da diagonal de D são os elmentos da diagonal de res*res&#39;</span></span>
<span id="cb123-12"><a href="#cb123-12"></a>  resposta &lt;-<span class="st"> </span>bloco_<span class="dv">1</span><span class="op">%*%</span><span class="kw">t</span>(x)<span class="op">%*%</span>D<span class="op">%*%</span>x<span class="op">%*%</span><span class="kw">t</span>(bloco_<span class="dv">1</span>)</span>
<span id="cb123-13"><a href="#cb123-13"></a>  <span class="kw">return</span>(resposta)</span>
<span id="cb123-14"><a href="#cb123-14"></a>}</span></code></pre></div>
<p>Veja que a função <code>variancia_mqo</code>recebe só <span class="math inline">\(X\)</span> e y e todo o resto das contas são feitos por funções que criamos originalmente: o coeficiente é calculado pela função <code>mqo</code>, que passa isso para a função <code>residuo</code>, que por sua vez passa o resultado para obtermos a variância do estimador.</p>
<p>Vamos construir uma função final que devolve os coeficientes e o erro padrão. Mais ainda, eu vou adicionar uma mopção que adiciona um intercepto (as funções acima não fazem isso!). Para isso, observe que um intercepto é somente colar uma coluna de 1s na matriz X. Então, na função <code>regressao</code>, eu vou adicionar uma opção <code>intercepto</code>, que vai ser um booleano (verdadeiro ou falso). Se for verdadeiro, eu adiciono uma coluna de 1s. Se você apostou que eu vou fazer isso usando um <code>if</code>, parabéns: é exatamente o que eu vou fazer. Para deixar a coisa mais completa, a função vai ter como padrão adicionar o intercepto:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb124-1"><a href="#cb124-1"></a>regressao &lt;-<span class="st"> </span><span class="cf">function</span>(x,y,<span class="dt">intercepto =</span> T){</span>
<span id="cb124-2"><a href="#cb124-2"></a>  <span class="cf">if</span>(intercepto <span class="op">==</span><span class="st"> </span>T){</span>
<span id="cb124-3"><a href="#cb124-3"></a>    x &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dv">1</span>,x) <span class="co">#Veja o comentário abaixo</span></span>
<span id="cb124-4"><a href="#cb124-4"></a>  } <span class="co"># como o caso else não faz nada, eu posso simplesmente não colocar nada no else</span></span>
<span id="cb124-5"><a href="#cb124-5"></a>  coefs &lt;-<span class="st"> </span><span class="kw">mqo</span>(x,y)</span>
<span id="cb124-6"><a href="#cb124-6"></a>  vars &lt;-<span class="st"> </span><span class="kw">diag</span>(<span class="kw">variancia_mqo</span>(x,y)) <span class="co">#Diag extrai a diagonal da matriz de variância do coeficiente - e é isso que nos interessa</span></span>
<span id="cb124-7"><a href="#cb124-7"></a>  <span class="kw">return</span>(<span class="kw">cbind</span>(coefs,<span class="kw">sqrt</span>(vars)))</span>
<span id="cb124-8"><a href="#cb124-8"></a>}</span></code></pre></div>
<p>Veja que ao fazer <code>cbind(1,x)</code>, o R é inteligente o suficiente para repetir 1 o número de linhas de x, sem termos que nos preocupar em definir um vetor 1 do mesmo número de linhas que a matriz <span class="math inline">\(X\)</span>.Vamos testar a nossa função, comparado com o comando padrão do R, <code>lm</code>:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb125-1"><a href="#cb125-1"></a>X &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">500</span>),<span class="dt">ncol =</span> <span class="dv">5</span>)</span>
<span id="cb125-2"><a href="#cb125-2"></a>y &lt;-<span class="st"> </span>X<span class="op">%*%</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">2</span>,<span class="fl">0.5</span>) <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">100</span>)</span>
<span id="cb125-3"><a href="#cb125-3"></a></span>
<span id="cb125-4"><a href="#cb125-4"></a><span class="kw">regressao</span>(X,y)</span></code></pre></div>
<pre><code>##            [,1]       [,2]
## [1,]  0.1479876 0.10669330
## [2,]  1.0856303 0.08981977
## [3,] -0.8327885 0.08729072
## [4,]  1.9488739 0.10540215
## [5,] -2.0157979 0.13226224
## [6,]  0.5108700 0.09746306</code></pre>
<div class="sourceCode" id="cb127"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb127-1"><a href="#cb127-1"></a><span class="kw">summary</span>(<span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>X))</span></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = y ~ X)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -2.3436 -0.6873  0.1224  0.6271  2.4932 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  0.14799    0.10468   1.414    0.161    
## X1           1.08563    0.10291  10.549  &lt; 2e-16 ***
## X2          -0.83279    0.10055  -8.283 8.12e-13 ***
## X3           1.94887    0.09865  19.755  &lt; 2e-16 ***
## X4          -2.01580    0.10556 -19.097  &lt; 2e-16 ***
## X5           0.51087    0.09773   5.227 1.04e-06 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 1.029 on 94 degrees of freedom
## Multiple R-squared:  0.9225, Adjusted R-squared:  0.9184 
## F-statistic: 223.7 on 5 and 94 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>Veja que há uma leve diferença entre os erros padrões computados pela minha função e pelo <code>lm</code>. Isso se deve ao fato do R assumir erros homocedásticos e a matriz de variância covariância que nós implementamos não assume isso.</p>
<p>##LASSO</p>
<table>
<tr>
<td>
Dificuldade
</td>
<td>
Intermediário
</td>
</tr>
<tr>
<td>
Capítulos necessários
</td>
<td>
8 e 6 (somente para o último passo)
</td>
</tr>
</table>
<p>LASSO (Least Absolute Shrinkage and Selection Operator) é uma maneira de fazer regressão quando temos muitas variáveis e queremos selecionar só as que são relevantes - potencialmente, podemos ter mais variáveis que observações! Formalmente, o LASSO resolve:</p>
<p><span class="math display">\[\beta_{LASSO} = \text{argmin}_\beta \sum_i (y_i - x_i\beta) \text{ sujeito a } \sum_k |\beta_k| &lt; c\]</span>
Onde k indexa as variáveis do problema. No fundo, estamos resolvendo o problema de minimização usual de mínimos quadrados, com uma restrição: a soma do valor <em>absoluto</em> dos coeficientes não pode passar de um valor <span class="math inline">\(c\)</span>, que tem que ser determinado<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a>. Veja que, por incrível que pareça, o fato de usarmos o valor absoluto é bastante importante: usar uma restrição com a soma dos quadrados reduz os coeficientes, mas não joga nenhum deles para zero. Uma explicação bastante intuitiva sobre o porque usar o valor absoluto e mais sobre o LASSO em geral, pode ser encontrada no excelente <em>Statistical Learning with Sparsity</em>, de Trevor Hastie, Robert Tibshirani e Martin Wainwright (que pode ser encontrado <a href="https://web.stanford.edu/~hastie/StatLearnSparsity_files/SLS_corrected_1.4.16.pdf">aqui</a>)</p>
<p>Vamos implementar o LASSO usando o CVXR. Vamos criar um conjunto de de variáveis <span class="math inline">\(X\)</span>, com 100 observações e 50 variáveis, e definir um <span class="math inline">\(y\)</span> que depende de alguma dessas variáveis (as 10 primeiras, talvez. Mas não muito mais que isso!). Escolha os coeficientes que quiser, mas tente manter os coeficientes longe de zero. Eu escolherei, preguisosamente, 1 para todas as variáveis relevantes. Adicione algum erro no y, exatamente imitando o problema usual de uma regressão. O passo seguinte é escrever o programa do CVXR e mandar ele resolver o nosso problema:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb129-1"><a href="#cb129-1"></a>X &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">5000</span>),<span class="dt">ncol =</span> <span class="dv">50</span>)</span>
<span id="cb129-2"><a href="#cb129-2"></a>beta &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>,<span class="dv">10</span>),<span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">40</span>))</span>
<span id="cb129-3"><a href="#cb129-3"></a>y &lt;-<span class="st"> </span>X<span class="op">%*%</span>beta <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">100</span>)</span>
<span id="cb129-4"><a href="#cb129-4"></a></span>
<span id="cb129-5"><a href="#cb129-5"></a><span class="kw">library</span>(CVXR)</span></code></pre></div>
<pre><code>## 
## Attaching package: &#39;CVXR&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:MASS&#39;:
## 
##     huber</code></pre>
<pre><code>## The following object is masked from &#39;package:stats&#39;:
## 
##     power</code></pre>
<div class="sourceCode" id="cb133"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb133-1"><a href="#cb133-1"></a>c &lt;-<span class="st"> </span><span class="dv">10</span> <span class="co">#esse é o valor que vai limitar a soma do valor dos coeficientes. Eu escolhi o valor exato que é a soma dos meus coeficientes, mas você pode (e deve) brincar com isso aqui</span></span>
<span id="cb133-2"><a href="#cb133-2"></a></span>
<span id="cb133-3"><a href="#cb133-3"></a>beta_hat &lt;-<span class="st"> </span><span class="kw">Variable</span>(<span class="dv">50</span>)</span>
<span id="cb133-4"><a href="#cb133-4"></a>obj &lt;-<span class="st"> </span><span class="kw">Minimize</span>(<span class="kw">sum</span>((y<span class="op">-</span>X<span class="op">%*%</span>beta_hat)<span class="op">^</span><span class="dv">2</span>)) <span class="co">#essa é a função objetivo</span></span>
<span id="cb133-5"><a href="#cb133-5"></a>cons &lt;-<span class="st"> </span><span class="kw">sum</span>(<span class="kw">abs</span>(beta_hat)) <span class="op">&lt;=</span><span class="st"> </span>c</span>
<span id="cb133-6"><a href="#cb133-6"></a>prob &lt;-<span class="st"> </span><span class="kw">Problem</span>(obj,<span class="dt">constraints =</span> <span class="kw">list</span>(cons))</span>
<span id="cb133-7"><a href="#cb133-7"></a>soluc &lt;-<span class="st"> </span><span class="kw">solve</span>(prob)</span>
<span id="cb133-8"><a href="#cb133-8"></a>est &lt;-<span class="st"> </span>soluc<span class="op">$</span><span class="kw">getValue</span>(beta_hat) <span class="co">#para extrair os betas estimados</span></span>
<span id="cb133-9"><a href="#cb133-9"></a>est[est<span class="op">&lt;</span><span class="fl">1e-9</span>] &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co">#Veja o comentário abaixo</span></span>
<span id="cb133-10"><a href="#cb133-10"></a>est</span></code></pre></div>
<pre><code>##              [,1]
##  [1,] 1.114767661
##  [2,] 0.925086427
##  [3,] 0.840888221
##  [4,] 0.822393215
##  [5,] 0.950351379
##  [6,] 0.770954833
##  [7,] 0.954209258
##  [8,] 0.943797513
##  [9,] 0.833047121
## [10,] 0.803394150
## [11,] 0.000000000
## [12,] 0.000000000
## [13,] 0.000000000
## [14,] 0.101425883
## [15,] 0.000000000
## [16,] 0.002027388
## [17,] 0.000000000
## [18,] 0.000000000
## [19,] 0.000000000
## [20,] 0.000000000
## [21,] 0.000000000
## [22,] 0.000000000
## [23,] 0.000000000
## [24,] 0.000000000
## [25,] 0.000000000
## [26,] 0.000000000
## [27,] 0.000000000
## [28,] 0.000000000
## [29,] 0.004798918
## [30,] 0.053302837
## [31,] 0.000000000
## [32,] 0.000000000
## [33,] 0.000000000
## [34,] 0.000000000
## [35,] 0.000000000
## [36,] 0.059377076
## [37,] 0.112852557
## [38,] 0.000000000
## [39,] 0.053778779
## [40,] 0.000000000
## [41,] 0.236131556
## [42,] 0.000000000
## [43,] 0.000000000
## [44,] 0.000000000
## [45,] 0.081179623
## [46,] 0.085582381
## [47,] 0.000000000
## [48,] 0.029926644
## [49,] 0.000000000
## [50,] 0.041631793</code></pre>
<p>Veja que, além do CVXR, eu adicionei um <code>est[est&lt;1e-9] &lt;- 0</code>. Como já dito no Capítulo 8, estimativas númericas nunca vão chegar exatamente em zero. Então, para deixar o <em>output</em> mais legível, eu estou estabelecendo que qualquer valor abaixo de <span class="math inline">\(10^{-9}\)</span> é zero. Veja que <span class="math inline">\(10^{-9}\)</span> é arbitrário e as implementações de verdade usam padrões estabelecidos.</p>
<p>Voltando ao LASSO: veja que o algoritmo faz um bom trabalho, zerando vários coeficientes. Ele não zera todos os coeficientes das variáveis que não deveriam ser incluídas, mas em compensação não zera nenhum coeficiente das variáveis que deveriam ser incluídas. Trocando em miúdos: ele dá falsos positivos, mas não falsos negativos. Isso é verdade, em geral.</p>
<p>Obviamente, o trabalho fica bem mais limpo se escrevermos uma função que faz tudo isso para quaisquer X,y e c escolhidos. Aproveite o código que já escrevemos e escreva uma função que faça isso para qualquer X,y e c. Não esqueça que você vai ter que alterar o tamanho do <code>beta_hat</code> (Dica: veja o comando <code>ncol</code>).</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb135-1"><a href="#cb135-1"></a>lasso &lt;-<span class="st"> </span><span class="cf">function</span>(X,y,c){</span>
<span id="cb135-2"><a href="#cb135-2"></a>  beta_hat &lt;-<span class="st"> </span><span class="kw">Variable</span>(<span class="kw">ncol</span>(X))</span>
<span id="cb135-3"><a href="#cb135-3"></a>  obj &lt;-<span class="st"> </span><span class="kw">Minimize</span>(<span class="kw">sum</span>((y<span class="op">-</span>X<span class="op">%*%</span>beta_hat)<span class="op">^</span><span class="dv">2</span>)) <span class="co">#essa é a função objetivo</span></span>
<span id="cb135-4"><a href="#cb135-4"></a>  cons &lt;-<span class="st"> </span><span class="kw">sum</span>(<span class="kw">abs</span>(beta_hat)) <span class="op">&lt;=</span><span class="st"> </span>c</span>
<span id="cb135-5"><a href="#cb135-5"></a>  prob &lt;-<span class="st"> </span><span class="kw">Problem</span>(obj,<span class="dt">constraints =</span> <span class="kw">list</span>(cons))</span>
<span id="cb135-6"><a href="#cb135-6"></a>  soluc &lt;-<span class="st"> </span><span class="kw">solve</span>(prob)</span>
<span id="cb135-7"><a href="#cb135-7"></a>  est &lt;-<span class="st"> </span>soluc<span class="op">$</span><span class="kw">getValue</span>(beta_hat) <span class="co">#para extrair os betas estimados</span></span>
<span id="cb135-8"><a href="#cb135-8"></a>  est[est<span class="op">&lt;</span><span class="fl">1e-9</span>] &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co">#Veja o comentário abaixo</span></span>
<span id="cb135-9"><a href="#cb135-9"></a>  <span class="kw">return</span>(est)</span>
<span id="cb135-10"><a href="#cb135-10"></a>}</span></code></pre></div>
<p>Veja que eu fui tão preguiçoso ao escrever a função que nem mesmo os comentários mudaram!</p>
<p>Em situações em que você queira usar o LASSO, o pacote <strong>glmnet</strong> faz o LASSO até mesmo para modelos Probit e Logit, e é infinitamente superior a implementação acima.</p>

<p>#Referências</p>
<p>Todas as referências a seguir são em inglês. Isso reflete justamente a limitação da literatura em português sobre R e economia - o exato motivo da confecção deste manual.</p>
<p>##R</p>
<p>Dois livros foram essenciais para este autor aprender a usar o R: o <em>R Book</em>, de Michael J. Crawley e o <em>Applied Econometrics with R</em>, de Christian Kleiber e Achim Zeileis. O primeiro é extremamente geral e cobre de tudo, explicando muito dos tópicos tratados aqui superficialmente com muito mais detalhes. O segundo tem um título auto explicativo.</p>
<p>##Tidyverse</p>
<p>Uma omissão notável desse manual são os pacotes do <em>Tidyverse</em>, especialmente o Dplyr e o ggplot, que são muito usados para limpar dados e fazer gráficos, respectivamente. O autor desses pacotes, Hadley Wickham, tem um excelente livro sobre como fazer ciência de dados no R, chamado <em>R for Data Science</em>, e que o próprio disponibiliza <a href="http://r4ds.had.co.nz/">aqui</a>. O <a href="https://www.tidyverse.org/">site do Tidyverse</a> também traz excelentes recursos de como usar esses pacotes.</p>
<p>##LaTeX</p>
<p>Um dos melhores recursos para aprender LaTeX é o livro da wikipedia sobre a linguagem, disponível <a href="https://en.wikibooks.org/wiki/LaTeX">aqui</a>. Felizmente, não é sequer necessário instalar o LaTeX no computador, já que existem serviços online que fornecem armazenamento e um editor de LaTeX online. Os dois mais famosos são o <a href="https://www.overleaf.com/">overleaf</a> e o <a href="https://pt.sharelatex.com/">sharelatex</a>.</p>



















<div class="footnotes">
<hr />
<ol start="1">
<li id="fn1"><p>Letras em vermelho ocorrem em algumas outras situações.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>Dois iguais seguidos<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>Dois iguais seguidos<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>Em geral. O autor já encontrou situações em que esse tipo de solução era estritamente necessária.<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>Se você leu a discussão anterior de tipos de objetos, vale observar que reg é uma lista<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>Nada haver com carro: é uma sigla para Companion to Applied Reggresion<a href="#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p>Nem sempre o R vai ignorar um NA. Isso depende do pacote e das configurações do R<a href="#fnref7" class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p>Espaços, cedilhas e acentos são normalmente uma má ideia em nomes de arquivos.<a href="#fnref8" class="footnote-back">↩︎</a></p></li>
<li id="fn9"><p>Alguém poderia argumentar que isso sempre será possível, pois é necessário muito azar para gerar uma matriz desse jeito que é singular. Mas é só um exemplo.<a href="#fnref9" class="footnote-back">↩︎</a></p></li>
<li id="fn10"><p>Letras em vermelho ocorrem em algumas outras situações.<a href="#fnref10" class="footnote-back">↩︎</a></p></li>
<li id="fn11"><p>Isso é familiar?<a href="#fnref11" class="footnote-back">↩︎</a></p></li>
<li id="fn12"><p>Veja que fora da diagonal temos apenas zeros: isso faz sentido no caso iid, onde não esperamos correlação entre os erros<a href="#fnref12" class="footnote-back">↩︎</a></p></li>
<li id="fn13"><p>Não vou entrar nessa discussão, mas o que as implementações fazem, em geral, é colocar vários valores de <span class="math inline">\(c\)</span>, desde baixos o bastante para que nenhuma variável ser incluída até um valor alto suficiente que todas são incluídas. Como escolher qual desses <span class="math inline">\(c\)</span> usar não é óbvio.<a href="#fnref13" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>


    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["Bookdown.pdf", "Bookdown.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
