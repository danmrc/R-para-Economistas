[["dplyr-manipulando-dados.html", "Capítulo 4 Dplyr: manipulando dados 4.1 Pipes 4.2 Filter 4.3 mutate 4.4 group_by 4.5 rename 4.6 select 4.7 joins 4.8 summarise", " Capítulo 4 Dplyr: manipulando dados Além da base do R, existem outros pacotes para manipulação de dados. O dplyr e o tidyr são dois deles, que facilitam certas operações e são muito usados. Nós vamos usar este pacote para manipular os dados (em painel) de acidentes de carro nos EUA. Este dados estão no livro do Stock &amp; Watson e estão disponíveis no pacote AER. Vamos dar uma olhada no nome das variáveis: library(AER) data(&quot;Fatalities&quot;) names(Fatalities) ## [1] &quot;state&quot; &quot;year&quot; &quot;spirits&quot; &quot;unemp&quot; &quot;income&quot; ## [6] &quot;emppop&quot; &quot;beertax&quot; &quot;baptist&quot; &quot;mormon&quot; &quot;drinkage&quot; ## [11] &quot;dry&quot; &quot;youngdrivers&quot; &quot;miles&quot; &quot;breath&quot; &quot;jail&quot; ## [16] &quot;service&quot; &quot;fatal&quot; &quot;nfatal&quot; &quot;sfatal&quot; &quot;fatal1517&quot; ## [21] &quot;nfatal1517&quot; &quot;fatal1820&quot; &quot;nfatal1820&quot; &quot;fatal2124&quot; &quot;nfatal2124&quot; ## [26] &quot;afatal&quot; &quot;pop&quot; &quot;pop1517&quot; &quot;pop1820&quot; &quot;pop2124&quot; ## [31] &quot;milestot&quot; &quot;unempus&quot; &quot;emppopus&quot; &quot;gsp&quot; Cada linha varia conforme duas variáveis, o estado (dos EUA) e o ano. O dplyr é particularmente adequado para trabalhar com este tipo de dados. Cada seção a seguir vai explorar um comando ou dois Eu também vou carregar o dplyr: library(dplyr) 4.1 Pipes Frequentemente, as pessoas usam pipes ao usar o dplyr. O pipe não é parte do dplyr e pode ser usado em outras aplicações, mas a frequência em que os dois aparecem associados é tão alta que vale a pena discutir o pipe. O pipe é %&gt;% e significa “e então”. Por exemplo, os códigos abaixos fazem a mesma coisa - somam todos os números inteiros de 1 a 50: obj1 &lt;- sum(1:50) obj2 &lt;- 1:50 %&gt;% sum() obj1 == obj2 ## [1] TRUE Nós listamos todos os elementos de 1 a 50 e então somamos eles. Nós podemos ter quantas expressões nós queremos concatenadas. Veja que a função sum é chamada sem nenhum argumento, porque ela recebe o argumento antes do pipe. Se a função recebe mais de um argumento, o pipe vai sempre substituir o primeiro argumento da função. Por exemplo, se eu quisesse usar a opção da função sum de eliminar NA do vetor, eu faria: obj2 &lt;- 1:50 %&gt;% sum(na.rm = TRUE) Na próxima seção, eu vou apresentar uma função do dplyr usando e não usando pipe. 4.2 Filter A primeira função que nós vamos tratar do dply é o filter. Ele permite a gente filtrar os dados (as linhas), eliminando linhas que não atendem a uma condição. Um exemplo muito básico é eliminar todos os anos menores que 1982 da base de fatalidades: fatal_1 &lt;- Fatalities %&gt;% filter(as.numeric(year) &gt; 1982) fatal_2 &lt;- filter(Fatalities,as.numeric(year) &gt; 1982) (O as.numeric(year) é uma ligeira gambiarra, porque a variável year é um fator, e fatores não tem uma definição natural de ordem) Os dataframes fatal_1 e fatal_2 são idênticos, mas o fatal_1 foi criado com o uso do pipe. De agora por diante Nós podemos combinar condições. Por exemplo, nós podemos querer todos os acidentes que acontecem apenas depois de 1982 e não acontecem no Alaska: fatal_3 &lt;- Fatalities %&gt;% filter(as.numeric(year) &gt; 1982 &amp; state != &quot;al&quot;) 4.3 mutate O mutate é outra função do dplyr que permite você alterar ou criar novas variáveis. Por exemplo, a variável mormon no dataframe nos dá a porcentagem de mormons no estado. Mas o número está com base 100 - um estado com 63% de mormons terá uma entrada 63 nesta coluna - o que eu acho inconveniente. Vamos alterar para a base ser 1 - nesse caso, um estado com 63% de mormons terá uma entrada 0.63: fatal_1 &lt;- Fatalities %&gt;% mutate(mormon = mormon/100) Nós podemos usar o mutate para criar novas variáveis. Por exemplo, a base tem as variáveis fatal1517 e fatal1820, com o número de fatalidades com pessoas entre 15 e 17 anos e 18 e 20 anos, respectivamente. Nós podemos querer criar uma nova variável que é a soma das duas variáveis: fatal_2 &lt;- fatal_1 %&gt;% mutate(fatalities_young = fatal1517 + fatal1820) Nós podemos criar duas variáveis no mesmo mutate e operar com uma variável que acabamos de definir. Por exemplo, nós podemos criar a variável de fatalidade de jovens, como no bloco de código anterior e criar uma nova variável que é a proporção de fatalidades de jovens dado o total de fatalidades (o total de fatalidades é a variável fatal): fatal_3 &lt;- fatal_1 %&gt;% mutate(fatalities_young = fatal1517 + fatal1820, fatalities_young_prop = fatalities_young/fatal) 4.4 group_by O group_by é talvez a função mais importante do dplyr: ele permite agrupar linhas que pertencem ao mesmo grupo com base em uma variável. A estrutura de painel se presta muito a isso: as linhas podem ser agrupdas por pertencer ao mesmo ano ou a mesma unidade. Ao usar group_by, nós podemos realizar operações sobre unidades que pertencem ao mesmo grupo sem nenhum esforço. Veja que o group_by sozinho não altera nada do dataframe, ele só permite que outras funções do dplyr valham para o mesmo grupo. 4.4.1 group_by e mutate Vamos ilustrar o uso do group_by e do mutate com o painel Fatalities. Eu vou criar uma variável que é a proporção de fatalidades de cada estado no mesmo ano. O grupo é a variável ano, e a proporção de fatalidades de cada estado é \\(fatal_i/ \\left(\\sum_{i} fatal_i \\right)\\), onde fatal é a variável de fatalidades e \\(i\\) indexa os estados: fatal_df &lt;- Fatalities %&gt;% group_by(year) %&gt;% mutate(prop_fatal = fatal/sum(fatal)) Por exemplo, vamos ver a situação de 1985. Se nós somarmos prop_fatal dentro de um ano e tudo tiver dado certo, a variável deve somar 1: fatal_df &lt;- fatal_df %&gt;% filter(year==1985) prop_teste &lt;- fatal_df$prop_fatal sum(prop_teste) ## [1] 1 4.5 rename O rename permite mudar o nome de uma coluna. Por exemplo, nós podemos querer mudar o nome da variável de mortes de fatal para fatalities: fatal_4 &lt;- Fatalities %&gt;% rename(&quot;fatalities&quot; = fatal) É meio curioso, na minhca cabeça, que do lado esquerdo venha o nome novo e do lado direito venha o nome antigo. 4.5.1 rename_with* Nós às vezes queremos renomear várias colunas, e o rename_with faz exatamente isso. Eu vou renomear todas as colunas que começam com fatal para fatalities. Isso vai exigir uns três truques novos e o pacote stringr, e eu vou colocar o código e explicar o que cada parte faz: library(stringr) fatal_4 &lt;- Fatalities %&gt;% rename_with(.cols=starts_with(&quot;fatal&quot;),.fn = ~str_replace(.,&quot;fatal&quot;,&quot;fatalities&quot;)) names(fatal_4) ## [1] &quot;state&quot; &quot;year&quot; &quot;spirits&quot; &quot;unemp&quot; ## [5] &quot;income&quot; &quot;emppop&quot; &quot;beertax&quot; &quot;baptist&quot; ## [9] &quot;mormon&quot; &quot;drinkage&quot; &quot;dry&quot; &quot;youngdrivers&quot; ## [13] &quot;miles&quot; &quot;breath&quot; &quot;jail&quot; &quot;service&quot; ## [17] &quot;fatalities&quot; &quot;nfatal&quot; &quot;sfatal&quot; &quot;fatalities1517&quot; ## [21] &quot;nfatal1517&quot; &quot;fatalities1820&quot; &quot;nfatal1820&quot; &quot;fatalities2124&quot; ## [25] &quot;nfatal2124&quot; &quot;afatal&quot; &quot;pop&quot; &quot;pop1517&quot; ## [29] &quot;pop1820&quot; &quot;pop2124&quot; &quot;milestot&quot; &quot;unempus&quot; ## [33] &quot;emppopus&quot; &quot;gsp&quot; O rename_with precisa saber quais colunas alterar - o argumento .cols - e como alterar - o argumento .fn. No .cols, nós escolhemos todas as variáveis que começam com (isso é a função start_with) a palavra “fatal”. O argumento .fn recebe uma função que vai ser usada para mudar o nome da variável. Eu usei uma função do pacote stringr, str_replace. A str_replace recebe um vetor, um termo para procurar e o termo que substitui. Nesse caso, o str_replace procurar por “fatal” e substitui por “fatalities”. Mas o código não acabou ai, porque eu usei ~str_replace(.,\"fatal\",\"fatalities\"): eu não expliquei o til e o ponto. O til e o ponto são uma maneira de definir uma função dentro do dplyr. O primeiro argumento do str_replace (o vetor com os nomes) pelo que a função rename_with passa (o nome das variáveis). Essa construção vai aparecer na próxima seção. 4.6 select O select permite selecionar colunas ao invés de linhas. Isso permite jogar fora ou manter apenas algumas colunas. Por exemplo, nós podemos selecionar apenas os estados, ano, fatalidades e a idade mínima para beber para criar um dataframe menor - que pode ser bem útil para fazer gráficos, por exemplo: df_menor &lt;- Fatalities %&gt;% select(state,year,fatal,drinkage) Note que não colocamos aspas no nome das variáveis. É bem mais frequente eu querer jogar algumas variáveis fora, e você pode fazer isso usando o select colocando um menos na frente do nome da variável. Por exemplo, eu vou jogar fora a variável gsp (que eu não faço ideia do que seja): fatal_5 &lt;- Fatalities %&gt;% select(-gsp) 4.7 joins Frequentemente nós queremos juntar duas bases de dados. Nem sempre as duas bases de dados estão “alinhadas”. Por exemplo, imagine uma base de dados que tem o nome dos estados em alguma ordem e nós queremos juntar com a base de Fatalities. Nós poderíamos alinhar as duas bases e ai usar algum comando do R. Os comandos de _join permitem juntar bases com colunas em comum pela variável. Nós vamos precisar de uma segunda base de dados para fazer isso, e eu vou usar a base de adoção de cinto de segurança nos EUA: data(&quot;USSeatBelts&quot;) names(USSeatBelts) ## [1] &quot;state&quot; &quot;year&quot; &quot;miles&quot; &quot;fatalities&quot; &quot;seatbelt&quot; ## [6] &quot;speed65&quot; &quot;speed70&quot; &quot;drinkage&quot; &quot;alcohol&quot; &quot;income&quot; ## [11] &quot;age&quot; &quot;enforce&quot; Veja que a base tem tanto uma coluna estados como uma coluna ano. É sempre bom checar que as variáveis são compátiveis. Por exemplo, uma base pode ter nomes de estados e a outra sigla de estados; pode não existir nenhum ano em comum entre as duas bases: head(USSeatBelts$state) ## [1] AK AK AK AK AK AK ## 51 Levels: AK AL AR AZ CA CO CT DC DE FL GA HI IA ID IL IN KS KY LA MA ... WY head(USSeatBelts$year) ## [1] 1983 1984 1985 1986 1987 1988 ## 15 Levels: 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 ... 1997 (a função head() mostra apenas o começo do vetor ou de um dataframe, o que permite a gente inspecionar como são os dados em geral.) A sigla do estado em USSeatBelts em maiúscula, enquanto na Fatalities é em minúscula. Para não gerar nenhum problema, eu vou transformar tudo em minúscula. Mais ainda, eu vou usar o select. para manter apenas as variáveis que me interessam (o estado, o ano e se há enforcement de cinto de segurança): seatbelt &lt;- USSeatBelts %&gt;% select(state,year,enforce) %&gt;% mutate(state = tolower(state)) Agora vamos voltar a discussão do join. Existem vários tipos de join: left_join, que toma o primeiro dataframe como referência e joga fora linhas do segundo dataframe que não tem um correspondente no primeiro dataframe right_join, que toma o segundo dataframe como referência e joga fora as linhas do primeiro dataframe que não tem um correspondente no segundo dataframe (o caso oposto de left_join) inner_join que só mantém os casos em comum dos dois dataframes full_join que mantém todas as linhas dos dois dataframes (e preenchem as colunas que só estão disponível para alguns casos com NA) Talvez isso seja um pouco difícil de imaginar, mas visualmente é bem simples. Considere as duas tabelas a seguir: Tabela 1: id var 1 var 2 1 1 9 2 2 8 Tabela 2: id var 3 var 4 1 “aa” “zz” 3 “bb” “vv” A coluna id é a coluna em comum, e será usada para juntar as duas tabelas. Um left_join(tabela 1, tabela 2) produziria: id var 1 var 2 var 3 var 4 1 1 9 “aa” “zz” 2 2 8 NA NA Um right_join(tabela 1, tabela 2) produziria: id var 3 var 4 var 1 var 2 1 “aa” “zz” 1 9 3 “bb” “vv” NA NA Um inner join manteria apenas a linha 1, enquanto um full_join geraria: id var 3 var 4 var 1 var 2 1 “aa” “zz” 1 9 2 NA NA 2 8 3 “bb” “vv” NA NA Voltando ao código, eu vou fazer um left_join entre as duas bases, com a base de fatalidades como o primeiro argumento: novo_df &lt;- left_join(Fatalities,seatbelt) ## Joining, by = c(&quot;state&quot;, &quot;year&quot;) head(novo_df) ## state year spirits unemp income emppop beertax baptist mormon drinkage ## 1 al 1982 1.37 14.4 10544.15 50.69204 1.539379 30.3557 0.32829 19.00 ## 2 al 1983 1.36 13.7 10732.80 52.14703 1.788991 30.3336 0.34341 19.00 ## 3 al 1984 1.32 11.1 11108.79 54.16809 1.714286 30.3115 0.35924 19.00 ## 4 al 1985 1.28 8.9 11332.63 55.27114 1.652542 30.2895 0.37579 19.67 ## 5 al 1986 1.23 9.8 11661.51 56.51450 1.609907 30.2674 0.39311 21.00 ## 6 al 1987 1.18 7.8 11944.00 57.50988 1.560000 30.2453 0.41123 21.00 ## dry youngdrivers miles breath jail service fatal nfatal sfatal ## 1 25.0063 0.211572 7233.887 no no no 839 146 99 ## 2 22.9942 0.210768 7836.348 no no no 930 154 98 ## 3 24.0426 0.211484 8262.990 no no no 932 165 94 ## 4 23.6339 0.211140 8726.917 no no no 882 146 98 ## 5 23.4647 0.213400 8952.854 no no no 1081 172 119 ## 6 23.7924 0.215527 9166.302 no no no 1110 181 114 ## fatal1517 nfatal1517 fatal1820 nfatal1820 fatal2124 nfatal2124 afatal ## 1 53 9 99 34 120 32 309.438 ## 2 71 8 108 26 124 35 341.834 ## 3 49 7 103 25 118 34 304.872 ## 4 66 9 100 23 114 45 276.742 ## 5 82 10 120 23 119 29 360.716 ## 6 94 11 127 31 138 30 368.421 ## pop pop1517 pop1820 pop2124 milestot unempus emppopus gsp ## 1 3942002 208999.6 221553.4 290000.1 28516 9.7 57.8 -0.02212476 ## 2 3960008 202000.1 219125.5 290000.2 31032 9.6 57.9 0.04655825 ## 3 3988992 197000.0 216724.1 288000.2 32961 7.5 59.5 0.06279784 ## 4 4021008 194999.7 214349.0 284000.3 35091 7.2 60.1 0.02748997 ## 5 4049994 203999.9 212000.0 263000.3 36259 7.0 60.7 0.03214295 ## 6 4082999 204999.8 208998.5 258999.8 37426 6.2 61.5 0.04897637 ## enforce ## 1 &lt;NA&gt; ## 2 no ## 3 no ## 4 no ## 5 no ## 6 no 4.8 summarise Depois de manipular os dados, nós vamos olhar para algumas funções que resumem os dados. Quando nós fizermos o resumo, nós temos que escolher em qual nível nós vamos agregar os dados. No nosso exemplo, nós podemos querer saber a média de fatalidades por estado ou por ano. Nós usamos a função summarise para criar agregações e definimos o nível das agregações usando a função group_by. Eu vou tirar a média de fatalidades por ano: resumo &lt;- Fatalities %&gt;% group_by(year) %&gt;% summarise(mean(fatal)) resumo ## # A tibble: 7 × 2 ## year `mean(fatal)` ## &lt;fct&gt; &lt;dbl&gt; ## 1 1982 909. ## 2 1983 880. ## 3 1984 915. ## 4 1985 906. ## 5 1986 955. ## 6 1987 961. ## 7 1988 975. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
